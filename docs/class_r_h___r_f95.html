<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Soldered RF433 Arduino Library: RH_RF95 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Soldered RF433 Arduino Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">This is a Soldered RF433 Arduino Module</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_r_h___r_f95.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_r_h___r_f95-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RH_RF95 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.  
 <a href="class_r_h___r_f95.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_h___r_f95_8h_source.html">RH_RF95.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_r_h_s_p_i_driver.html">RHSPIDriver</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_h___r_f95_1_1_modem_config.html">ModemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines register values for a set of modem configuration registers.  <a href="struct_r_h___r_f95_1_1_modem_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9605810c11c025758ea91b2813666e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3">ModemConfigChoice</a> { <a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3a36c80b8c976c6209e9c929669a0ab320">Bw125Cr45Sf128</a> = 0
, <a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3a1759bc33893056f011b81e62e5c8af5f">Bw500Cr45Sf128</a>
, <a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3a78f89711f429422d920dc22dbc278548">Bw31_25Cr48Sf512</a>
, <a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3a241b28dcbb17f8a86e3f8edd03c51b21">Bw125Cr48Sf4096</a>
 }</td></tr>
<tr class="separator:ab9605810c11c025758ea91b2813666e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a7c96558708f18937bc2fa7341f217937 inherit pub_types_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> { <br />
&#160;&#160;<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937ad901fedd5b99db75c942023971632c43">RHModeInitialising</a> = 0
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHModeSleep</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHModeIdle</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHModeTx</a>
, <br />
&#160;&#160;<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHModeRx</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a36997733490b61f1997529c8cfeb4211">RHModeCad</a>
<br />
 }</td></tr>
<tr class="memdesc:a7c96558708f18937bc2fa7341f217937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different operating modes for the transport hardware.  <a href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">More...</a><br /></td></tr>
<tr class="separator:a7c96558708f18937bc2fa7341f217937 inherit pub_types_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a274c170acdb53f55fd45445ab7f51889"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a274c170acdb53f55fd45445ab7f51889">RH_RF95</a> (uint8_t slaveSelectPin=SS, uint8_t interruptPin=2, <a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;spi=<a class="el" href="_r_h_hardware_s_p_i_8h.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a>)</td></tr>
<tr class="separator:a274c170acdb53f55fd45445ab7f51889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bee6fb7ad0e0d0ae5e04ed27cfd79d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">init</a> ()</td></tr>
<tr class="separator:aa7bee6fb7ad0e0d0ae5e04ed27cfd79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a441a5946b538f60f31e727009750"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#af82a441a5946b538f60f31e727009750">printRegisters</a> ()</td></tr>
<tr class="separator:af82a441a5946b538f60f31e727009750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa191d9634325354102394b856c47b5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#aa191d9634325354102394b856c47b5ba">setModemRegisters</a> (const <a class="el" href="struct_r_h___r_f95_1_1_modem_config.html">ModemConfig</a> *config)</td></tr>
<tr class="separator:aa191d9634325354102394b856c47b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f6131a36c2a0f84a5883a6ec7acfec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#af6f6131a36c2a0f84a5883a6ec7acfec">setModemConfig</a> (<a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3">ModemConfigChoice</a> index)</td></tr>
<tr class="separator:af6f6131a36c2a0f84a5883a6ec7acfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a6b16ca2be2da530516220560cf43"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a917a6b16ca2be2da530516220560cf43">available</a> ()</td></tr>
<tr class="separator:a917a6b16ca2be2da530516220560cf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bca98b1e9abd1c55aaa32d10ea9631b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a8bca98b1e9abd1c55aaa32d10ea9631b">recv</a> (uint8_t *buf, uint8_t *len)</td></tr>
<tr class="separator:a8bca98b1e9abd1c55aaa32d10ea9631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d3743511fdcc1b41f5f8e6b0964c1f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ae7d3743511fdcc1b41f5f8e6b0964c1f">send</a> (const uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:ae7d3743511fdcc1b41f5f8e6b0964c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f16c9b450bdd13a421d282e58a09fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#af0f16c9b450bdd13a421d282e58a09fb">setPreambleLength</a> (uint16_t bytes)</td></tr>
<tr class="separator:af0f16c9b450bdd13a421d282e58a09fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af910c0670d3f3cc158355f20a2361485"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#af910c0670d3f3cc158355f20a2361485">maxMessageLength</a> ()</td></tr>
<tr class="separator:af910c0670d3f3cc158355f20a2361485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854c2eaa2f3cf9583453ff09f15e1099"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a854c2eaa2f3cf9583453ff09f15e1099">setFrequency</a> (float centre)</td></tr>
<tr class="separator:a854c2eaa2f3cf9583453ff09f15e1099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b9fd0c59274f5d0bfcc622757c2eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a44b9fd0c59274f5d0bfcc622757c2eeb">setModeIdle</a> ()</td></tr>
<tr class="separator:a44b9fd0c59274f5d0bfcc622757c2eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade668dcd0730fef266c8d94c7e6e7085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ade668dcd0730fef266c8d94c7e6e7085">setModeRx</a> ()</td></tr>
<tr class="separator:ade668dcd0730fef266c8d94c7e6e7085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46330e9d7ec87255b91d0e4297cc8814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a46330e9d7ec87255b91d0e4297cc8814">setModeTx</a> ()</td></tr>
<tr class="separator:a46330e9d7ec87255b91d0e4297cc8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab273e242758e3cc2ed2679ef795a7196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ab273e242758e3cc2ed2679ef795a7196">setTxPower</a> (int8_t power, bool useRFO=false)</td></tr>
<tr class="separator:ab273e242758e3cc2ed2679ef795a7196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9184ab8aec1c3c54a275d08c7e85c66"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#aa9184ab8aec1c3c54a275d08c7e85c66">sleep</a> ()</td></tr>
<tr class="separator:aa9184ab8aec1c3c54a275d08c7e85c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4fef2a1f40e704055bff09799f08cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a6f4fef2a1f40e704055bff09799f08cf">isChannelActive</a> ()</td></tr>
<tr class="separator:a6f4fef2a1f40e704055bff09799f08cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19637b6378b779306c04ca611082bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ad19637b6378b779306c04ca611082bf6">enableTCXO</a> ()</td></tr>
<tr class="separator:ad19637b6378b779306c04ca611082bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96154a00662d73f69b9858597c8d4c9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a96154a00662d73f69b9858597c8d4c9b">frequencyError</a> ()</td></tr>
<tr class="separator:a96154a00662d73f69b9858597c8d4c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13efb0779e4bc522986f272201cb43cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a13efb0779e4bc522986f272201cb43cf">lastSNR</a> ()</td></tr>
<tr class="separator:a13efb0779e4bc522986f272201cb43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea770963212a64b35169f0f0c35c14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#abea770963212a64b35169f0f0c35c14d">setSpreadingFactor</a> (uint8_t sf)</td></tr>
<tr class="separator:abea770963212a64b35169f0f0c35c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ba623bba31f200e50e46686ec61176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a02ba623bba31f200e50e46686ec61176">setSignalBandwidth</a> (long sbw)</td></tr>
<tr class="separator:a02ba623bba31f200e50e46686ec61176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7edba1cc8e33512c0b1721758bd0077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ad7edba1cc8e33512c0b1721758bd0077">setCodingRate4</a> (uint8_t denominator)</td></tr>
<tr class="separator:ad7edba1cc8e33512c0b1721758bd0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2df6a6d2cb192b13bd572a7005da67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a8e2df6a6d2cb192b13bd572a7005da67">setLowDatarate</a> ()</td></tr>
<tr class="separator:a8e2df6a6d2cb192b13bd572a7005da67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b402c77236b0dfe3ec68e953faa02dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a9b402c77236b0dfe3ec68e953faa02dd">setPayloadCRC</a> (bool on)</td></tr>
<tr class="separator:a9b402c77236b0dfe3ec68e953faa02dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_h_s_p_i_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_h_s_p_i_driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_h_s_p_i_driver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a4285d2fb96b09588556bfc4f8a143f61">RHSPIDriver</a> (uint8_t slaveSelectPin=SS, <a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;spi=<a class="el" href="_r_h_hardware_s_p_i_8h.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a>)</td></tr>
<tr class="separator:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a7ba5e6fc53e02ff8125218bc296b4557">init</a> ()</td></tr>
<tr class="separator:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a275b8c3d4d27a59d8f93a036b17bbf22">spiRead</a> (uint8_t reg)</td></tr>
<tr class="separator:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a649210bd63262e23c9becabfc7142fd3">spiWrite</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#af0ffebc1db1a6008734a37c4448fe926">spiBurstRead</a> (uint8_t reg, uint8_t *dest, uint8_t len)</td></tr>
<tr class="separator:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a559b2c489825fe1ae737cb4371956d3d">spiBurstWrite</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cc3ee4a7cceb8b283e2efc3f2a6362 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a89cc3ee4a7cceb8b283e2efc3f2a6362">setSlaveSelectPin</a> (uint8_t slaveSelectPin)</td></tr>
<tr class="separator:a89cc3ee4a7cceb8b283e2efc3f2a6362 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2a8e0b99bec6997aff996d644b554 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#a21b2a8e0b99bec6997aff996d644b554">spiUsingInterrupt</a> (uint8_t interruptNumber)</td></tr>
<tr class="separator:a21b2a8e0b99bec6997aff996d644b554 inherit pub_methods_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aacf1b301be4cc16800a62632df6fdd37">RHGenericDriver</a> ()</td></tr>
<tr class="memdesc:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_r_h_generic_driver.html#aacf1b301be4cc16800a62632df6fdd37">More...</a><br /></td></tr>
<tr class="separator:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1cfcd4d6187702c364cf4c81e76365 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3e1cfcd4d6187702c364cf4c81e76365">init</a> ()</td></tr>
<tr class="separator:a3e1cfcd4d6187702c364cf4c81e76365 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd522b8eb16c51dc948b4ca4d623888 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2dd522b8eb16c51dc948b4ca4d623888">available</a> ()=0</td></tr>
<tr class="separator:a2dd522b8eb16c51dc948b4ca4d623888 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f0f64dff770bbeb1b197a5fca0579a inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a58f0f64dff770bbeb1b197a5fca0579a">recv</a> (uint8_t *buf, uint8_t *len)=0</td></tr>
<tr class="separator:a58f0f64dff770bbeb1b197a5fca0579a inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716069edea652af8019daaeb64357ee inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5716069edea652af8019daaeb64357ee">send</a> (const uint8_t *data, uint8_t len)=0</td></tr>
<tr class="separator:a5716069edea652af8019daaeb64357ee inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267459de4eb3032c5efb8b220af7d164 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a267459de4eb3032c5efb8b220af7d164">maxMessageLength</a> ()=0</td></tr>
<tr class="separator:a267459de4eb3032c5efb8b220af7d164 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf108e52389353cb3658b6802b92c77c inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf108e52389353cb3658b6802b92c77c">waitAvailable</a> ()</td></tr>
<tr class="separator:abf108e52389353cb3658b6802b92c77c inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent</a> ()</td></tr>
<tr class="separator:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a0feda1f5522522dc50e0c26dcdef71dd">waitPacketSent</a> (uint16_t timeout)</td></tr>
<tr class="separator:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a8ed545cecc22196a325333dc9637e4cf">waitAvailableTimeout</a> (uint16_t timeout)</td></tr>
<tr class="separator:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#ac577b932ba8b042b8170b24d513635c7">waitCAD</a> ()</td></tr>
<tr class="separator:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a445039899f159c02bf6e642e3e12d9b9">setCADTimeout</a> (unsigned long cad_timeout)</td></tr>
<tr class="separator:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#af4bc85a58ebc777ea1f3b57f3ae87b1b">isChannelActive</a> ()</td></tr>
<tr class="separator:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5e8f15e1e7480899d18c3a21248bb628">setThisAddress</a> (uint8_t thisAddress)</td></tr>
<tr class="separator:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a182436232f7a345bca0d1766d242f3fb">setHeaderTo</a> (uint8_t to)</td></tr>
<tr class="separator:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a470e67f4168dec41435dcc0e194202c8">setHeaderFrom</a> (uint8_t from)</td></tr>
<tr class="separator:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a4dd57079264bda98bc89145fe5d2eb8f">setHeaderId</a> (uint8_t id)</td></tr>
<tr class="separator:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#acb992b3c5e360e68b67e4843558bcf3b">setHeaderFlags</a> (uint8_t set, uint8_t clear=RH_FLAGS_APPLICATION_SPECIFIC)</td></tr>
<tr class="separator:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2791f57538b02a73e7dbe1031048230e">setPromiscuous</a> (bool promiscuous)</td></tr>
<tr class="separator:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a6f49c9fe68354b50988dec435fa8d086">headerTo</a> ()</td></tr>
<tr class="separator:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a8cf7a972186592c51c6fde034d17ab9f">headerFrom</a> ()</td></tr>
<tr class="separator:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a81548960bb29a3ac35325c74cd562f45">headerId</a> ()</td></tr>
<tr class="separator:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a056fbd2df558971fe8a1653499a37c63">headerFlags</a> ()</td></tr>
<tr class="separator:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi</a> ()</td></tr>
<tr class="separator:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a> ()</td></tr>
<tr class="separator:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aa1c0a94ba6414b5bbab0133c4d74e646">setMode</a> (<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> <a class="el" href="class_r_h_generic_driver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a>)</td></tr>
<tr class="memdesc:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operating mode of the transport.  <a href="class_r_h_generic_driver.html#aa1c0a94ba6414b5bbab0133c4d74e646">More...</a><br /></td></tr>
<tr class="separator:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97050555cbf46ad723ad9c45d7f76a55 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a97050555cbf46ad723ad9c45d7f76a55">sleep</a> ()</td></tr>
<tr class="separator:a97050555cbf46ad723ad9c45d7f76a55 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a0163fb71dc8d0cd86136882886adba7f">rxBad</a> ()</td></tr>
<tr class="separator:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5f730e644ab1f5f529fdfa82fdb2ed69">rxGood</a> ()</td></tr>
<tr class="separator:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a66a408f88a1188a0fab458816cb705f4">txGood</a> ()</td></tr>
<tr class="separator:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a18191ee8063c7beec84671abb184aef4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a18191ee8063c7beec84671abb184aef4">handleInterrupt</a> ()</td></tr>
<tr class="separator:a18191ee8063c7beec84671abb184aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09086214734986feeb1e647a7820b615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a09086214734986feeb1e647a7820b615">validateRxBuf</a> ()</td></tr>
<tr class="memdesc:a09086214734986feeb1e647a7820b615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine the revceive buffer to determine whether the message is for this node.  <a href="class_r_h___r_f95.html#a09086214734986feeb1e647a7820b615">More...</a><br /></td></tr>
<tr class="separator:a09086214734986feeb1e647a7820b615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af385a295c834e88610dfcfb4112fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a1af385a295c834e88610dfcfb4112fb2">clearRxBuf</a> ()</td></tr>
<tr class="memdesc:a1af385a295c834e88610dfcfb4112fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear our local receive buffer.  <a href="class_r_h___r_f95.html#a1af385a295c834e88610dfcfb4112fb2">More...</a><br /></td></tr>
<tr class="separator:a1af385a295c834e88610dfcfb4112fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a7d1d574c24de1f7d4971fa06cc166c7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a7d1d574c24de1f7d4971fa06cc166c7f">isr0</a> ()</td></tr>
<tr class="memdesc:a7d1d574c24de1f7d4971fa06cc166c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 0.  <a href="class_r_h___r_f95.html#a7d1d574c24de1f7d4971fa06cc166c7f">More...</a><br /></td></tr>
<tr class="separator:a7d1d574c24de1f7d4971fa06cc166c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae351a13bb0d022a0dbf6d55b9631195e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ae351a13bb0d022a0dbf6d55b9631195e">isr1</a> ()</td></tr>
<tr class="memdesc:ae351a13bb0d022a0dbf6d55b9631195e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 1.  <a href="class_r_h___r_f95.html#ae351a13bb0d022a0dbf6d55b9631195e">More...</a><br /></td></tr>
<tr class="separator:ae351a13bb0d022a0dbf6d55b9631195e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adc0c6029b10de04bda31de199e98ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a2adc0c6029b10de04bda31de199e98ed">isr2</a> ()</td></tr>
<tr class="memdesc:a2adc0c6029b10de04bda31de199e98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 1.  <a href="class_r_h___r_f95.html#a2adc0c6029b10de04bda31de199e98ed">More...</a><br /></td></tr>
<tr class="separator:a2adc0c6029b10de04bda31de199e98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9f43cda8dd8d5edc5508937393dfce13"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a9f43cda8dd8d5edc5508937393dfce13">_interruptPin</a></td></tr>
<tr class="memdesc:a9f43cda8dd8d5edc5508937393dfce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured interrupt pin connected to this instance.  <a href="class_r_h___r_f95.html#a9f43cda8dd8d5edc5508937393dfce13">More...</a><br /></td></tr>
<tr class="separator:a9f43cda8dd8d5edc5508937393dfce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c2394e5b1e52aa15adbff92b3e229"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a358c2394e5b1e52aa15adbff92b3e229">_myInterruptIndex</a></td></tr>
<tr class="separator:a358c2394e5b1e52aa15adbff92b3e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553f8428e9528dc43a78a983b379110"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#aa553f8428e9528dc43a78a983b379110">_bufLen</a></td></tr>
<tr class="memdesc:aa553f8428e9528dc43a78a983b379110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of octets in the buffer.  <a href="class_r_h___r_f95.html#aa553f8428e9528dc43a78a983b379110">More...</a><br /></td></tr>
<tr class="separator:aa553f8428e9528dc43a78a983b379110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b4c17fd74f962a3af6f6a7e7bc4b8a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#ac9b4c17fd74f962a3af6f6a7e7bc4b8a">_buf</a> [RH_RF95_MAX_PAYLOAD_LEN]</td></tr>
<tr class="memdesc:ac9b4c17fd74f962a3af6f6a7e7bc4b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The receiver/transmitter buffer.  <a href="class_r_h___r_f95.html#ac9b4c17fd74f962a3af6f6a7e7bc4b8a">More...</a><br /></td></tr>
<tr class="separator:ac9b4c17fd74f962a3af6f6a7e7bc4b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d4a80e90eb918841c2e63d79536f5d"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a03d4a80e90eb918841c2e63d79536f5d">_rxBufValid</a></td></tr>
<tr class="memdesc:a03d4a80e90eb918841c2e63d79536f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True when there is a valid message in the buffer.  <a href="class_r_h___r_f95.html#a03d4a80e90eb918841c2e63d79536f5d">More...</a><br /></td></tr>
<tr class="separator:a03d4a80e90eb918841c2e63d79536f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430db47e388aba6f7690abe017aa7e58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a430db47e388aba6f7690abe017aa7e58">_usingHFport</a></td></tr>
<tr class="separator:a430db47e388aba6f7690abe017aa7e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646ae738f52f7fe9871ce21f4df8f9e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a6646ae738f52f7fe9871ce21f4df8f9e">_lastSNR</a></td></tr>
<tr class="separator:a6646ae738f52f7fe9871ce21f4df8f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:abb55a3dea7023d199e38c3200c811fe2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_r_h___r_f95.html">RH_RF95</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#abb55a3dea7023d199e38c3200c811fe2">_deviceForInterrupt</a> [] = {0, 0, 0}</td></tr>
<tr class="memdesc:abb55a3dea7023d199e38c3200c811fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instances connected to interrupts 0 and 1.  <a href="class_r_h___r_f95.html#abb55a3dea7023d199e38c3200c811fe2">More...</a><br /></td></tr>
<tr class="separator:abb55a3dea7023d199e38c3200c811fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6dd8b1fa38a3275501f37a52d78aad"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___r_f95.html#a0c6dd8b1fa38a3275501f37a52d78aad">_interruptCount</a> = 0</td></tr>
<tr class="memdesc:a0c6dd8b1fa38a3275501f37a52d78aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of next interrupt number to use in _deviceForInterrupt.  <a href="class_r_h___r_f95.html#a0c6dd8b1fa38a3275501f37a52d78aad">More...</a><br /></td></tr>
<tr class="separator:a0c6dd8b1fa38a3275501f37a52d78aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a63915f6420833eb8ec61ee3b0610e34b">printBuffer</a> (const char *prompt, const uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_r_h_s_p_i_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_r_h_s_p_i_driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_r_h_s_p_i_driver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#ad9ee8d997815ec209d3208967107ffb1">_spi</a></td></tr>
<tr class="memdesc:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the <a class="el" href="class_r_h_generic_s_p_i.html" title="Base class for SPI interfaces.">RHGenericSPI</a> instance to use to transfer data with the SPI device.  <a href="class_r_h_s_p_i_driver.html#ad9ee8d997815ec209d3208967107ffb1">More...</a><br /></td></tr>
<tr class="separator:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#ab63525878860cc6ab6c4a994ce704735">_slaveSelectPin</a></td></tr>
<tr class="memdesc:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pin number of the Slave Select pin that is used to select the desired device.  <a href="class_r_h_s_p_i_driver.html#ab63525878860cc6ab6c4a994ce704735">More...</a><br /></td></tr>
<tr class="separator:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44c6997fbe63b00059b85c50654d5ef inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_s_p_i_driver.html#aa44c6997fbe63b00059b85c50654d5ef">_interuptPin</a></td></tr>
<tr class="separator:aa44c6997fbe63b00059b85c50654d5ef inherit pro_attribs_class_r_h_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a324854a5f898b0a48ec83424351730c5">_mode</a></td></tr>
<tr class="memdesc:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current transport operating mode.  <a href="class_r_h_generic_driver.html#a324854a5f898b0a48ec83424351730c5">More...</a><br /></td></tr>
<tr class="separator:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a6d2e9824e29c9d5e9ad28682e53ea974">_thisAddress</a></td></tr>
<tr class="memdesc:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node id.  <a href="class_r_h_generic_driver.html#a6d2e9824e29c9d5e9ad28682e53ea974">More...</a><br /></td></tr>
<tr class="separator:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2d94c93203714ed3dd9a7434101683e9">_promiscuous</a></td></tr>
<tr class="memdesc:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transport is in promiscuous mode.  <a href="class_r_h_generic_driver.html#a2d94c93203714ed3dd9a7434101683e9">More...</a><br /></td></tr>
<tr class="separator:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abff3740bc072a2d435194a7860b2bfe3">_rxHeaderTo</a></td></tr>
<tr class="memdesc:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header in the last received mesasge.  <a href="class_r_h_generic_driver.html#abff3740bc072a2d435194a7860b2bfe3">More...</a><br /></td></tr>
<tr class="separator:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7283cfec4e7c1ecf074307534592fd8f">_rxHeaderFrom</a></td></tr>
<tr class="memdesc:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header in the last received mesasge.  <a href="class_r_h_generic_driver.html#a7283cfec4e7c1ecf074307534592fd8f">More...</a><br /></td></tr>
<tr class="separator:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3155557c35198acdde0ecdf58a201b19">_rxHeaderId</a></td></tr>
<tr class="memdesc:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header in the last received mesasge.  <a href="class_r_h_generic_driver.html#a3155557c35198acdde0ecdf58a201b19">More...</a><br /></td></tr>
<tr class="separator:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">_rxHeaderFlags</a></td></tr>
<tr class="memdesc:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header in the last received mesasge.  <a href="class_r_h_generic_driver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">More...</a><br /></td></tr>
<tr class="separator:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a759debcdbdb837cea024f777020203e5">_txHeaderTo</a></td></tr>
<tr class="memdesc:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header to send in all messages.  <a href="class_r_h_generic_driver.html#a759debcdbdb837cea024f777020203e5">More...</a><br /></td></tr>
<tr class="separator:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">_txHeaderFrom</a></td></tr>
<tr class="memdesc:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header to send in all messages.  <a href="class_r_h_generic_driver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">More...</a><br /></td></tr>
<tr class="separator:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#ad0eafb5a8316b90ad8cd9d42234517da">_txHeaderId</a></td></tr>
<tr class="memdesc:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header to send in all messages.  <a href="class_r_h_generic_driver.html#ad0eafb5a8316b90ad8cd9d42234517da">More...</a><br /></td></tr>
<tr class="separator:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf4db9bddfee361cc44fbf4bd22202bc">_txHeaderFlags</a></td></tr>
<tr class="memdesc:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header to send in all messages.  <a href="class_r_h_generic_driver.html#abf4db9bddfee361cc44fbf4bd22202bc">More...</a><br /></td></tr>
<tr class="separator:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a9b67eea20e8f9a688d61a5a6b6b2be03">_lastRssi</a></td></tr>
<tr class="memdesc:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the last received RSSI value, in some transport specific units.  <a href="class_r_h_generic_driver.html#a9b67eea20e8f9a688d61a5a6b6b2be03">More...</a><br /></td></tr>
<tr class="separator:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3bafd8dc638309a473367c4ff8e59c0e">_rxBad</a></td></tr>
<tr class="memdesc:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (eg bad checksum etc) received.  <a href="class_r_h_generic_driver.html#a3bafd8dc638309a473367c4ff8e59c0e">More...</a><br /></td></tr>
<tr class="separator:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">_rxGood</a></td></tr>
<tr class="memdesc:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of successfully transmitted messaged.  <a href="class_r_h_generic_driver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">More...</a><br /></td></tr>
<tr class="separator:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5f71653ad58e35ddca7fe3e052674ca2">_txGood</a></td></tr>
<tr class="memdesc:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (correct checksum etc) received.  <a href="class_r_h_generic_driver.html#a5f71653ad58e35ddca7fe3e052674ca2">More...</a><br /></td></tr>
<tr class="separator:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a028f651c56df90b8b9d852e16ac3356e">_cad</a></td></tr>
<tr class="memdesc:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity detected.  <a href="class_r_h_generic_driver.html#a028f651c56df90b8b9d852e16ac3356e">More...</a><br /></td></tr>
<tr class="separator:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3e86bc833626b8255fbc43917932d0d6">_cad_timeout</a></td></tr>
<tr class="memdesc:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity timeout in ms.  <a href="class_r_h_generic_driver.html#a3e86bc833626b8255fbc43917932d0d6">More...</a><br /></td></tr>
<tr class="separator:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver. </p>
<p >For Semtech SX1276/77/78/79 and HopeRF RF95/96/97/98 and other similar LoRa capable radios. Based on <a href="http://www.hoperf.com/upload/rf/RFM95_96_97_98W.pdf">http://www.hoperf.com/upload/rf/RFM95_96_97_98W.pdf</a> and <a href="http://www.hoperf.cn/upload/rfchip/RF96_97_98.pdf">http://www.hoperf.cn/upload/rfchip/RF96_97_98.pdf</a> and <a href="http://www.semtech.com/images/datasheet/LoraDesignGuide_STD.pdf">http://www.semtech.com/images/datasheet/LoraDesignGuide_STD.pdf</a> and <a href="http://www.semtech.com/images/datasheet/sx1276.pdf">http://www.semtech.com/images/datasheet/sx1276.pdf</a> and <a href="http://www.semtech.com/images/datasheet/sx1276_77_78_79.pdf">http://www.semtech.com/images/datasheet/sx1276_77_78_79.pdf</a> FSK/GFSK/OOK modes are not (yet) supported.</p>
<p >Works with</p><ul>
<li>the excellent MiniWirelessLoRa from Anarduino <a href="http://www.anarduino.com/miniwireless">http://www.anarduino.com/miniwireless</a></li>
<li>The excellent Modtronix inAir4 <a href="http://modtronix.com/inair4.html">http://modtronix.com/inair4.html</a> and inAir9 modules <a href="http://modtronix.com/inair9.html">http://modtronix.com/inair9.html</a>.</li>
<li>the excellent Rocket Scream Mini Ultra Pro with the RFM95W <a href="http://www.rocketscream.com/blog/product/mini-ultra-pro-with-radio/">http://www.rocketscream.com/blog/product/mini-ultra-pro-with-radio/</a></li>
<li>Lora1276 module from NiceRF <a href="http://www.nicerf.com/product_view.aspx?id=99">http://www.nicerf.com/product_view.aspx?id=99</a></li>
<li>Adafruit Feather M0 with RFM95</li>
<li>The very fine Talk2 Whisper Node LoRa boards <a href="https://wisen.com.au/store/products/whisper-node-lora">https://wisen.com.au/store/products/whisper-node-lora</a> an Arduino compatible board, which include an on-board RFM95/96 LoRa Radio (Semtech SX1276), external antenna, run on 2xAAA batteries and support low power operations. RF95 examples work without modification. Use Arduino Board Manager to install the Talk2 code support. Upload the code with an FTDI adapter set to 5V.</li>
<li>heltec / TTGO ESP32 LoRa OLED <a href="https://www.aliexpress.com/item/Internet-Development-Board-SX1278-ESP32-WIFI-chip-0-96-inch-OLED-Bluetooth-WIFI-Lora-Kit-32/32824535649.html">https://www.aliexpress.com/item/Internet-Development-Board-SX1278-ESP32-WIFI-chip-0-96-inch-OLED-Bluetooth-WIFI-Lora-Kit-32/32824535649.html</a></li>
</ul>
<dl class="section user"><dt>Overview</dt><dd></dd></dl>
<p>This class provides basic functions for sending and receiving unaddressed, unreliable datagrams of arbitrary length to 251 octets per packet.</p>
<p >Manager classes may use this class to implement reliable, addressed datagrams and streams, mesh routers, repeaters, translators etc.</p>
<p >Naturally, for any 2 radios to communicate that must be configured to use the same frequency and modulation scheme.</p>
<p >This Driver provides an object-oriented interface for sending and receiving data messages with Hope-RF RFM95/96/97/98(W), Semtech SX1276/77/78/79 and compatible radio modules in LoRa mode.</p>
<p >The Hope-RF (<a href="http://www.hoperf.com">http://www.hoperf.com</a>) RFM95/96/97/98(W) and Semtech SX1276/77/78/79 is a low-cost ISM transceiver chip. It supports FSK, GFSK, OOK over a wide range of frequencies and programmable data rates, and it also supports the proprietary LoRA (Long Range) mode, which is the only mode supported in this RadioHead driver.</p>
<p >This Driver provides functions for sending and receiving messages of up to 251 octets on any frequency supported by the radio, in a range of predefined Bandwidths, Spreading Factors and Coding Rates. Frequency can be set with 61Hz precision to any frequency from 240.0MHz to 960.0MHz. Caution: most modules only support a more limited range of frequencies due to antenna tuning.</p>
<p >Up to 2 modules can be connected to an Arduino (3 on a Mega), permitting the construction of translators and frequency changers, etc.</p>
<p >Support for other features such as transmitter power control etc is also provided.</p>
<p >Tested on MinWirelessLoRa with arduino-1.0.5 on OpenSuSE 13.1. Also tested with Teensy3.1, Modtronix inAir4 and Arduino 1.6.5 on OpenSuSE 13.1</p>
<dl class="section user"><dt>Packet Format</dt><dd></dd></dl>
<p>All messages sent and received by this <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> Driver conform to this packet format:</p>
<ul>
<li>LoRa mode:</li>
<li>8 symbol PREAMBLE</li>
<li>Explicit header with header CRC (handled internally by the radio)</li>
<li>4 octets HEADER: (TO, FROM, ID, FLAGS)</li>
<li>0 to 251 octets DATA</li>
<li>CRC (handled internally by the radio)</li>
</ul>
<dl class="section user"><dt>Connecting RFM95/96/97/98 and Semtech SX1276/77/78/79 to Arduino</dt><dd></dd></dl>
<p>We tested with Anarduino MiniWirelessLoRA, which is an Arduino Duemilanove compatible with a RFM96W module on-board. Therefore it needs no connections other than the USB programming connection and an antenna to make it work.</p>
<p >If you have a bare RFM95/96/97/98 that you want to connect to an Arduino, you might use these connections (untested): CAUTION: you must use a 3.3V type Arduino, otherwise you will also need voltage level shifters between the Arduino and the RFM95. CAUTION, you must also ensure you connect an antenna.</p>
<div class="fragment"><div class="line">                Arduino      RFM95/96/97/98</div>
<div class="line">                GND----------GND   (ground in)</div>
<div class="line">                3V3----------3.3V  (3.3V in)</div>
<div class="line"><a class="code hl_function" href="_r_h___a_s_k_8cpp.html#aebc9afd317d656680550a13818e71917">interrupt</a> 0 pin D2-----------DIO0  (<a class="code hl_function" href="_r_h___a_s_k_8cpp.html#aebc9afd317d656680550a13818e71917">interrupt</a> request out)</div>
<div class="line">         SS pin D10----------NSS   (CS chip select in)</div>
<div class="line">        SCK pin D13----------SCK   (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> clock in)</div>
<div class="line">       MOSI pin D11----------MOSI  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> Data in)</div>
<div class="line">       MISO pin D12----------MISO  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> Data out)</div>
<div class="ttc" id="a_r_h___a_s_k_8cpp_html_aebc9afd317d656680550a13818e71917"><div class="ttname"><a href="_r_h___a_s_k_8cpp.html#aebc9afd317d656680550a13818e71917">interrupt</a></div><div class="ttdeci">void interrupt()</div><div class="ttdef"><b>Definition:</b> RH_ASK.cpp:627</div></div>
<div class="ttc" id="a_r_h_hardware_s_p_i_8cpp_html_a5957ea19a6d6c4732ad338e86ff49ecb"><div class="ttname"><a href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a></div><div class="ttdeci">HardwareSPI SPI(1)</div></div>
</div><!-- fragment --><p> With these connections, you can then use the default constructor <a class="el" href="class_r_h___r_f95.html#a274c170acdb53f55fd45445ab7f51889">RH_RF95()</a>. You can override the default settings for the SS pin and the interrupt in the <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> constructor if you wish to connect the slave select SS to other than the normal one for your Arduino (D10 for Diecimila, Uno etc and D53 for Mega) or the interrupt request to other than pin D2 (Caution, different processors have different constraints as to the pins available for interrupts).</p>
<p >You can connect a Modtronix inAir4 or inAir9 directly to a 3.3V part such as a Teensy 3.1 like this (tested). </p><div class="fragment"><div class="line">                Teensy      inAir4 inAir9</div>
<div class="line">                GND----------0V   (ground in)</div>
<div class="line">                3V3----------3.3V  (3.3V in)</div>
<div class="line"><a class="code hl_function" href="_r_h___a_s_k_8cpp.html#aebc9afd317d656680550a13818e71917">interrupt</a> 0 pin D2-----------D0   (<a class="code hl_function" href="_r_h___a_s_k_8cpp.html#aebc9afd317d656680550a13818e71917">interrupt</a> request out)</div>
<div class="line">         SS pin D10----------CS    (CS chip select in)</div>
<div class="line">        SCK pin D13----------CK    (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> clock in)</div>
<div class="line">       MOSI pin D11----------SI    (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> Data in)</div>
<div class="line">       MISO pin D12----------SO    (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> Data out)</div>
</div><!-- fragment --><p> With these connections, you can then use the default constructor <a class="el" href="class_r_h___r_f95.html#a274c170acdb53f55fd45445ab7f51889">RH_RF95()</a>. you must also set the transmitter power with useRFO: driver.setTxPower(13, true);</p>
<p >Note that if you are using Modtronix inAir4 or inAir9,or any other module which uses the transmitter RFO pins and not the PA_BOOST pins that you must configure the power transmitter power for -1 to 14 dBm and with useRFO true. Failure to do that will result in extremely low transmit powers.</p>
<p >If you have an Arduino M0 Pro from arduino.org, you should note that you cannot use Pin 2 for the interrupt line (Pin 2 is for the NMI only). The same comments apply to Pin 4 on Arduino Zero from arduino.cc. Instead you can use any other pin (we use Pin 3) and initialise <a class="el" href="class_r_h___r_f69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> like this: </p><div class="fragment"><div class="line"><span class="comment">// Slave Select is pin 10, interrupt is Pin 3</span></div>
<div class="line"><a class="code hl_class" href="class_r_h___r_f95.html">RH_RF95</a> driver(10, 3);</div>
<div class="ttc" id="aclass_r_h___r_f95_html"><div class="ttname"><a href="class_r_h___r_f95.html">RH_RF95</a></div><div class="ttdoc">Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.</div><div class="ttdef"><b>Definition:</b> RH_RF95.h:565</div></div>
</div><!-- fragment --><p >If you have a Rocket Scream Mini Ultra Pro with the RFM95W:</p><ul>
<li>Ensure you have Arduino SAMD board support 1.6.5 or later in Arduino IDE 1.6.8 or later.</li>
<li>The radio SS is hardwired to pin D5 and the DIO0 interrupt to pin D2, so you need to initialise the radio like this: <div class="fragment"><div class="line"><a class="code hl_class" href="class_r_h___r_f95.html">RH_RF95</a> driver(5, 2);</div>
</div><!-- fragment --></li>
<li>The name of the serial port on that board is 'SerialUSB', not 'Serial', so this may be helpful at the top of our sample sketches: <div class="fragment"><div class="line"><span class="preprocessor">#define Serial SerialUSB</span></div>
</div><!-- fragment --></li>
<li>You also need this in setup before radio initialisation <br  />
 <div class="fragment"><div class="line"><span class="comment">// Ensure serial flash is not interfering with radio communication on SPI bus</span></div>
<div class="line"> <a class="code hl_function" href="_ras_pi_8cpp.html#a1875409d12eee562555bda94cad7f973">pinMode</a>(4, <a class="code hl_enumvalue" href="wirish_8h.html#a3e6ca6f0b3c7bbe79de5d3ec07877da1a2ab08d3e103968f5f4f26b66a52e99d6">OUTPUT</a>);</div>
<div class="line"> <a class="code hl_function" href="_ras_pi_8cpp.html#a21c224d04b05de3f68dce98958d02b7c">digitalWrite</a>(4, HIGH);</div>
<div class="ttc" id="a_ras_pi_8cpp_html_a1875409d12eee562555bda94cad7f973"><div class="ttname"><a href="_ras_pi_8cpp.html#a1875409d12eee562555bda94cad7f973">pinMode</a></div><div class="ttdeci">void pinMode(unsigned char pin, unsigned char mode)</div><div class="ttdef"><b>Definition:</b> RasPi.cpp:78</div></div>
<div class="ttc" id="a_ras_pi_8cpp_html_a21c224d04b05de3f68dce98958d02b7c"><div class="ttname"><a href="_ras_pi_8cpp.html#a21c224d04b05de3f68dce98958d02b7c">digitalWrite</a></div><div class="ttdeci">void digitalWrite(unsigned char pin, unsigned char value)</div><div class="ttdef"><b>Definition:</b> RasPi.cpp:90</div></div>
<div class="ttc" id="awirish_8h_html_a3e6ca6f0b3c7bbe79de5d3ec07877da1a2ab08d3e103968f5f4f26b66a52e99d6"><div class="ttname"><a href="wirish_8h.html#a3e6ca6f0b3c7bbe79de5d3ec07877da1a2ab08d3e103968f5f4f26b66a52e99d6">OUTPUT</a></div><div class="ttdeci">@ OUTPUT</div><div class="ttdef"><b>Definition:</b> wirish.h:16</div></div>
</div><!-- fragment --></li>
<li>and if you have a 915MHz part, you need this after driver/manager intitalisation: <div class="fragment"><div class="line">rf95.setFrequency(915.0);</div>
</div><!-- fragment --> which adds up to modifying sample sketches something like: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;SPI.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_r_h___r_f95_8h.html">RH_RF95.h</a>&gt;</span></div>
<div class="line"><a class="code hl_class" href="class_r_h___r_f95.html">RH_RF95</a> rf95(5, 2); <span class="comment">// Rocket Scream Mini Ultra Pro with the RFM95W</span></div>
<div class="line"><span class="preprocessor">#define Serial SerialUSB</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="wirish_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a>() </div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Ensure serial flash is not interfering with radio communication on SPI bus</span></div>
<div class="line">  <a class="code hl_function" href="_ras_pi_8cpp.html#a1875409d12eee562555bda94cad7f973">pinMode</a>(4, <a class="code hl_enumvalue" href="wirish_8h.html#a3e6ca6f0b3c7bbe79de5d3ec07877da1a2ab08d3e103968f5f4f26b66a52e99d6">OUTPUT</a>);</div>
<div class="line">  <a class="code hl_function" href="_ras_pi_8cpp.html#a21c224d04b05de3f68dce98958d02b7c">digitalWrite</a>(4, HIGH);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_variable" href="_ras_pi_8h.html#a25518c636d2f05e1fb53aaa4ac624305">Serial</a>.<a class="code hl_function" href="class_serial_simulator.html#ad02476735003ae14b468fbdfc8252253">begin</a>(9600);</div>
<div class="line">  <span class="keywordflow">while</span> (!<a class="code hl_variable" href="_ras_pi_8h.html#a25518c636d2f05e1fb53aaa4ac624305">Serial</a>) ; <span class="comment">// Wait for serial port to be available</span></div>
<div class="line">  <span class="keywordflow">if</span> (!rf95.init())</div>
<div class="line">    <a class="code hl_variable" href="_ras_pi_8h.html#a25518c636d2f05e1fb53aaa4ac624305">Serial</a>.<a class="code hl_function" href="class_serial_simulator.html#a7091e824733afdea0ff2a8baa2ad83d6">println</a>(<span class="stringliteral">&quot;init failed&quot;</span>);</div>
<div class="line">  rf95.setFrequency(915.0);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="a_r_h___r_f95_8h_html"><div class="ttname"><a href="_r_h___r_f95_8h.html">RH_RF95.h</a></div></div>
<div class="ttc" id="a_ras_pi_8h_html_a25518c636d2f05e1fb53aaa4ac624305"><div class="ttname"><a href="_ras_pi_8h.html#a25518c636d2f05e1fb53aaa4ac624305">Serial</a></div><div class="ttdeci">SerialSimulator Serial</div><div class="ttdef"><b>Definition:</b> simMain.cpp:15</div></div>
<div class="ttc" id="aclass_serial_simulator_html_a7091e824733afdea0ff2a8baa2ad83d6"><div class="ttname"><a href="class_serial_simulator.html#a7091e824733afdea0ff2a8baa2ad83d6">SerialSimulator::println</a></div><div class="ttdeci">static size_t println(const char *s)</div><div class="ttdef"><b>Definition:</b> RasPi.cpp:133</div></div>
<div class="ttc" id="aclass_serial_simulator_html_ad02476735003ae14b468fbdfc8252253"><div class="ttname"><a href="class_serial_simulator.html#ad02476735003ae14b468fbdfc8252253">SerialSimulator::begin</a></div><div class="ttdeci">static void begin(int baud)</div><div class="ttdef"><b>Definition:</b> RasPi.cpp:124</div></div>
<div class="ttc" id="awirish_8cpp_html_a4fc01d736fe50cf5b977f755b675f11d"><div class="ttname"><a href="wirish_8cpp.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a></div><div class="ttdeci">void setup()</div></div>
</div><!-- fragment --></li>
</ul>
<p >For Adafruit Feather M0 with RFM95, construct the driver like this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_r_h___r_f95.html">RH_RF95</a> rf95(8, 3);</div>
</div><!-- fragment --><p >If you have a talk2 Whisper Node LoRa board with on-board RF95 radio, the example rf95_* sketches work without modification. Initialise the radio like with the default constructor: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_r_h___r_f95.html">RH_RF95</a> driver;</div>
</div><!-- fragment --><p >It is possible to have 2 or more radios connected to one Arduino, provided each radio has its own SS and interrupt line (SCK, SDI and SDO are common to all radios)</p>
<p >Caution: on some Arduinos such as the Mega 2560, if you set the slave select pin to be other than the usual SS pin (D53 on Mega 2560), you may need to set the usual SS pin to be an output to force the Arduino into SPI master mode.</p>
<p >Caution: Power supply requirements of the RFM module may be relevant in some circumstances: RFM95/96/97/98 modules are capable of pulling 120mA+ at full power, where Arduino's 3.3V line can give 50mA. You may need to make provision for alternate power supply for the RFM module, especially if you wish to use full transmit power, and/or you have other shields demanding power. Inadequate power for the RFM is likely to cause symptoms such as:</p><ul>
<li>reset's/bootups terminate with "init failed" messages</li>
<li>random termination of communication after 5-30 packets sent/received</li>
<li>"fake ok" state, where initialization passes fluently, but communication doesn't happen</li>
<li>shields hang Arduino boards, especially during the flashing</li>
</ul>
<dl class="section user"><dt>Interrupts</dt><dd></dd></dl>
<p>The <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> driver uses interrupts to react to events in the RFM module, such as the reception of a new packet, or the completion of transmission of a packet. The <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> driver interrupt service routine reads status from and writes data to the the RFM module via the SPI interface. It is very important therefore, that if you are using the <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> driver with another SPI based deviced, that you disable interrupts while you transfer data to and from that other device. Use cli() to disable interrupts and sei() to reenable them.</p>
<dl class="section user"><dt>Memory</dt><dd></dd></dl>
<p>The <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> driver requires non-trivial amounts of memory. The sample programs all compile to about 8kbytes each, which will fit in the flash proram memory of most Arduinos. However, the RAM requirements are more critical. Therefore, you should be vary sparing with RAM use in programs that use the <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a> driver.</p>
<p >It is often hard to accurately identify when you are hitting RAM limits on Arduino. The symptoms can include:</p><ul>
<li>Mysterious crashes and restarts</li>
<li>Changes in behaviour when seemingly unrelated changes are made (such as adding print() statements)</li>
<li>Hanging</li>
<li>Output from Serial.print() not appearing</li>
</ul>
<dl class="section user"><dt>Range</dt><dd></dd></dl>
<p>We have made some simple range tests under the following conditions:</p><ul>
<li>rf95_client base station connected to a VHF discone antenna at 8m height above ground</li>
<li>rf95_server mobile connected to 17.3cm 1/4 wavelength antenna at 1m height, no ground plane.</li>
<li>Both configured for 13dBm, 434MHz, Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC on. Slow+long range</li>
<li>Minimum reported RSSI seen for successful comms was about -91</li>
<li>Range over flat ground through heavy trees and vegetation approx 2km.</li>
<li>At 20dBm (100mW) otherwise identical conditions approx 3km.</li>
<li>At 20dBm, along salt water flat sandy beach, 3.2km.</li>
</ul>
<p >It should be noted that at this data rate, a 12 octet message takes 2 seconds to transmit.</p>
<p >At 20dBm (100mW) with Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. (Default medium range) in the conditions described above.</p><ul>
<li>Range over flat ground through heavy trees and vegetation approx 2km.</li>
</ul>
<p >Caution: the performance of this radio, especially with narrow bandwidths is strongly dependent on the accuracy and stability of the chip clock. HopeRF and Semtech do not appear to recommend bandwidths of less than 62.5 kHz unless you have the optional Temperature Compensated Crystal Oscillator (TCXO) installed and enabled on your radio module. See the refernece manual for more data. Also <a href="https://lowpowerlab.com/forum/rf-range-antennas-rfm69-library/lora-library-experiences-range/15/">https://lowpowerlab.com/forum/rf-range-antennas-rfm69-library/lora-library-experiences-range/15/</a> and <a href="http://www.semtech.com/images/datasheet/an120014-xo-guidance-lora-modulation.pdf">http://www.semtech.com/images/datasheet/an120014-xo-guidance-lora-modulation.pdf</a></p>
<dl class="section user"><dt>Transmitter Power</dt><dd></dd></dl>
<p>You can control the transmitter power on the RF transceiver with the <a class="el" href="class_r_h___r_f95.html#ab273e242758e3cc2ed2679ef795a7196">RH_RF95::setTxPower()</a> function. The argument can be any of +5 to +23 (for modules that use PA_BOOST) -1 to +14 (for modules that use RFO transmitter pin) The default is 13. Eg: </p><div class="fragment"><div class="line">driver.<a class="code hl_function" href="class_r_h___r_f95.html#ab273e242758e3cc2ed2679ef795a7196">setTxPower</a>(10); <span class="comment">// use PA_BOOST transmitter pin</span></div>
<div class="line">driver.<a class="code hl_function" href="class_r_h___r_f95.html#ab273e242758e3cc2ed2679ef795a7196">setTxPower</a>(10, <span class="keyword">true</span>); <span class="comment">// use PA_RFO pin transmitter pin</span></div>
<div class="ttc" id="aclass_r_h___r_f95_html_ab273e242758e3cc2ed2679ef795a7196"><div class="ttname"><a href="class_r_h___r_f95.html#ab273e242758e3cc2ed2679ef795a7196">RH_RF95::setTxPower</a></div><div class="ttdeci">void setTxPower(int8_t power, bool useRFO=false)</div><div class="ttdef"><b>Definition:</b> RH_RF95.cpp:359</div></div>
</div><!-- fragment --><p >We have made some actual power measurements against programmed power for Anarduino MiniWirelessLoRa (which has RFM96W-433Mhz installed)</p><ul>
<li>MiniWirelessLoRa RFM96W-433Mhz, USB power</li>
<li>30cm RG316 soldered direct to RFM96W module ANT and GND</li>
<li>SMA connector</li>
<li>12db attenuator</li>
<li>SMA connector</li>
<li>MiniKits AD8307 HF/VHF Power Head (calibrated against Rohde&amp;Schwartz 806.2020 test set)</li>
<li>Tektronix TDS220 scope to measure the Vout from power head <div class="fragment"><div class="line">Program power           Measured Power</div>
<div class="line">   dBm                         dBm</div>
<div class="line">     5                           5</div>
<div class="line">     7                           7</div>
<div class="line">     9                           8</div>
<div class="line">    11                          11</div>
<div class="line">    13                          13</div>
<div class="line">    15                          15</div>
<div class="line">    17                          16</div>
<div class="line">    19                          18</div>
<div class="line">    20                          20 </div>
<div class="line">    21                          21 </div>
<div class="line">    22                          22 </div>
<div class="line">    23                          23 </div>
</div><!-- fragment --></li>
</ul>
<p >We have also measured the actual power output from a Modtronix inAir4 <a href="http://modtronix.com/inair4.html">http://modtronix.com/inair4.html</a> connected to a Teensy 3.1: Teensy 3.1 this is a 3.3V part, connected directly to: Modtronix inAir4 with SMA antenna connector, connected as above: 10cm SMA-SMA cable</p><ul>
<li>MiniKits AD8307 HF/VHF Power Head (calibrated against Rohde&amp;Schwartz 806.2020 test set)</li>
<li>Tektronix TDS220 scope to measure the Vout from power head <div class="fragment"><div class="line">Program power           Measured Power</div>
<div class="line">   dBm                         dBm</div>
<div class="line">     -1                         0</div>
<div class="line">     1                          2</div>
<div class="line">     3                          4</div>
<div class="line">     5                          7</div>
<div class="line">     7                         10</div>
<div class="line">     9                         13</div>
<div class="line">    11                         14.2</div>
<div class="line">    13                         15</div>
<div class="line">    14                         16</div>
</div><!-- fragment --> (Caution: we dont claim laboratory accuracy for these power measurements) You would not expect to get anywhere near these powers to air with a simple 1/4 wavelength wire antenna. </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab9605810c11c025758ea91b2813666e3" name="ab9605810c11c025758ea91b2813666e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9605810c11c025758ea91b2813666e3">&#9670;&nbsp;</a></span>ModemConfigChoice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3">RH_RF95::ModemConfigChoice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Choices for <a class="el" href="class_r_h___r_f95.html#af6f6131a36c2a0f84a5883a6ec7acfec">setModemConfig()</a> for a selected subset of common data rates. If you need another configuration, determine the necessary settings and call <a class="el" href="class_r_h___r_f95.html#aa191d9634325354102394b856c47b5ba">setModemRegisters()</a> with your desired settings. It might be helpful to use the LoRa calculator mentioned in <a href="http://www.semtech.com/images/datasheet/LoraDesignGuide_STD.pdf">http://www.semtech.com/images/datasheet/LoraDesignGuide_STD.pdf</a> These are indexes into MODEM_CONFIG_TABLE. We strongly recommend you use these symbolic definitions and not their integer equivalents: its possible that new values will be introduced in later versions (though we will try to avoid it). Caution: if you are using slow packet rates and long packets with <a class="el" href="class_r_h_reliable_datagram.html" title="RHDatagram subclass for sending addressed, acknowledged, retransmitted datagrams.">RHReliableDatagram</a> or subclasses you may need to change the <a class="el" href="class_r_h_reliable_datagram.html" title="RHDatagram subclass for sending addressed, acknowledged, retransmitted datagrams.">RHReliableDatagram</a> timeout for reliable operations. Caution: for some slow rates nad with ReliableDatagrams youi may need to increase the reply timeout with manager.setTimeout() to deal with the long transmission times. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9605810c11c025758ea91b2813666e3a36c80b8c976c6209e9c929669a0ab320" name="ab9605810c11c025758ea91b2813666e3a36c80b8c976c6209e9c929669a0ab320"></a>Bw125Cr45Sf128&#160;</td><td class="fielddoc"><p >Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Default medium range. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9605810c11c025758ea91b2813666e3a1759bc33893056f011b81e62e5c8af5f" name="ab9605810c11c025758ea91b2813666e3a1759bc33893056f011b81e62e5c8af5f"></a>Bw500Cr45Sf128&#160;</td><td class="fielddoc"><p >Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Fast+short range. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9605810c11c025758ea91b2813666e3a78f89711f429422d920dc22dbc278548" name="ab9605810c11c025758ea91b2813666e3a78f89711f429422d920dc22dbc278548"></a>Bw31_25Cr48Sf512&#160;</td><td class="fielddoc"><p >Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol, CRC on. Slow+long range. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9605810c11c025758ea91b2813666e3a241b28dcbb17f8a86e3f8edd03c51b21" name="ab9605810c11c025758ea91b2813666e3a241b28dcbb17f8a86e3f8edd03c51b21"></a>Bw125Cr48Sf4096&#160;</td><td class="fielddoc"><p >Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC on. Slow+long range. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a274c170acdb53f55fd45445ab7f51889" name="a274c170acdb53f55fd45445ab7f51889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274c170acdb53f55fd45445ab7f51889">&#9670;&nbsp;</a></span>RH_RF95()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RH_RF95::RH_RF95 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em> = <code>SS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptPin</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;&#160;</td>
          <td class="paramname"><em>spi</em> = <code><a class="el" href="_r_h_hardware_s_p_i_8h.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor. You can have multiple instances, but each instance must have its own interrupt and slave select pin. After constructing, you must call <a class="el" href="class_r_h___r_f95.html#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">init()</a> to initialise the interface and the radio module. A maximum of 3 instances can co-exist on one processor, provided there are sufficient distinct interrupt lines, one for each instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveSelectPin</td><td>the Arduino pin number of the output to use to select the <a class="el" href="class_r_h___r_f22.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF22 and compatible radio transce...">RH_RF22</a> before accessing it. Defaults to the normal SS pin for your Arduino (D10 for Diecimila, Uno etc, D53 for Mega, D10 for Maple) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptPin</td><td>The interrupt Pin number that is connected to the RFM DIO0 interrupt line. Defaults to pin 2, as required by Anarduino MinWirelessLoRa module. Caution: You must specify an interrupt capable pin. On many Arduino boards, there are limitations as to which pins may be used as interrupts. On Leonardo pins 0, 1, 2 or 3. On Mega2560 pins 2, 3, 18, 19, 20, 21. On Due and Teensy, any digital pin. On Arduino Zero from arduino.cc, any digital pin other than 4. On Arduino M0 Pro from arduino.org, any digital pin other than 2. On other Arduinos pins 2 or 3. See <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for more details. On Chipkit Uno32, pins 38, 2, 7, 8, 35. On other boards, any digital pin may be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the SPI interface object to use. Defaults to the standard Arduino hardware SPI interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a917a6b16ca2be2da530516220560cf43" name="a917a6b16ca2be2da530516220560cf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a6b16ca2be2da530516220560cf43">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tests whether a new message is available from the Driver. On most drivers, this will also put the Driver into RHModeRx mode until a message is actually received by the transport, when it wil be returned to RHModeIdle. This can be called multiple times in a timeout loop </p><dl class="section return"><dt>Returns</dt><dd>true if a new, complete, error-free uncollected message is available to be retreived by <a class="el" href="class_r_h___r_f95.html#a8bca98b1e9abd1c55aaa32d10ea9631b">recv()</a> </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a2dd522b8eb16c51dc948b4ca4d623888">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a1af385a295c834e88610dfcfb4112fb2" name="a1af385a295c834e88610dfcfb4112fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af385a295c834e88610dfcfb4112fb2">&#9670;&nbsp;</a></span>clearRxBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::clearRxBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear our local receive buffer. </p>

</div>
</div>
<a id="ad19637b6378b779306c04ca611082bf6" name="ad19637b6378b779306c04ca611082bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19637b6378b779306c04ca611082bf6">&#9670;&nbsp;</a></span>enableTCXO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::enableTCXO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enable TCXO mode Call this immediately after <a class="el" href="class_r_h___r_f95.html#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">init()</a>, to force your radio to use an external frequency source, such as a Temperature Compensated Crystal Oscillator (TCXO), if available. See the comments in the main documentation about the sensitivity of this radio to clock frequency especially when using narrow bandwidths. Leaves the module in sleep mode. Caution, this function has not been tested by us. Caution, the TCXO model radios are not low power when in sleep (consuming about ~600 uA, reported by Phang Moh Lim.<br  />
 </p>

</div>
</div>
<a id="a96154a00662d73f69b9858597c8d4c9b" name="a96154a00662d73f69b9858597c8d4c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96154a00662d73f69b9858597c8d4c9b">&#9670;&nbsp;</a></span>frequencyError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RH_RF95::frequencyError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the last measured frequency error. The LoRa receiver estimates the frequency offset between the receiver centre frequency and that of the received LoRa signal. This function returns the estimates offset (in Hz) of the last received message. Caution: this measurement is not absolute, but is measured relative to the local receiver's oscillator. Apparent errors may be due to the transmitter, the receiver or both. </p><dl class="section return"><dt>Returns</dt><dd>The estimated centre frequency offset in Hz of the last received message. If the modem bandwidth selector in register RH_RF95_REG_1D_MODEM_CONFIG1 is invalid, returns 0. </dd></dl>

</div>
</div>
<a id="a18191ee8063c7beec84671abb184aef4" name="a18191ee8063c7beec84671abb184aef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18191ee8063c7beec84671abb184aef4">&#9670;&nbsp;</a></span>handleInterrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::handleInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This is a low level function to handle the interrupts for one instance of <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a>. Called automatically by isr*() Should not need to be called by user code. </p>

</div>
</div>
<a id="aa7bee6fb7ad0e0d0ae5e04ed27cfd79d" name="aa7bee6fb7ad0e0d0ae5e04ed27cfd79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initialise the Driver transport hardware and software. Make sure the Driver is properly configured before calling <a class="el" href="class_r_h___r_f95.html#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">init()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if initialisation succeeded. </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#a3e1cfcd4d6187702c364cf4c81e76365">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a6f4fef2a1f40e704055bff09799f08cf" name="a6f4fef2a1f40e704055bff09799f08cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4fef2a1f40e704055bff09799f08cf">&#9670;&nbsp;</a></span>isChannelActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::isChannelActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Use the radio's Channel Activity Detect (CAD) function to detect channel activity. Sets the RF95 radio into CAD mode and waits until CAD detection is complete. To be used in a listen-before-talk mechanism (Collision Avoidance) with a reasonable time backoff algorithm. This is called automatically by <a class="el" href="class_r_h_generic_driver.html#ac577b932ba8b042b8170b24d513635c7">waitCAD()</a>. </p><dl class="section return"><dt>Returns</dt><dd>true if channel is in use. <br  />
 </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#af4bc85a58ebc777ea1f3b57f3ae87b1b">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a7d1d574c24de1f7d4971fa06cc166c7f" name="a7d1d574c24de1f7d4971fa06cc166c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1d574c24de1f7d4971fa06cc166c7f">&#9670;&nbsp;</a></span>isr0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::isr0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 0. </p>

</div>
</div>
<a id="ae351a13bb0d022a0dbf6d55b9631195e" name="ae351a13bb0d022a0dbf6d55b9631195e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae351a13bb0d022a0dbf6d55b9631195e">&#9670;&nbsp;</a></span>isr1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::isr1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 1. </p>

</div>
</div>
<a id="a2adc0c6029b10de04bda31de199e98ed" name="a2adc0c6029b10de04bda31de199e98ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adc0c6029b10de04bda31de199e98ed">&#9670;&nbsp;</a></span>isr2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::isr2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 1. </p>

</div>
</div>
<a id="a13efb0779e4bc522986f272201cb43cf" name="a13efb0779e4bc522986f272201cb43cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13efb0779e4bc522986f272201cb43cf">&#9670;&nbsp;</a></span>lastSNR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RH_RF95::lastSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the Signal-to-noise ratio (SNR) of the last received message, as measured by the receiver. </p><dl class="section return"><dt>Returns</dt><dd>SNR of the last received message in dB </dd></dl>

</div>
</div>
<a id="af910c0670d3f3cc158355f20a2361485" name="af910c0670d3f3cc158355f20a2361485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af910c0670d3f3cc158355f20a2361485">&#9670;&nbsp;</a></span>maxMessageLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF95::maxMessageLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the maximum message length available in this Driver. </p><dl class="section return"><dt>Returns</dt><dd>The maximum legal message length </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a267459de4eb3032c5efb8b220af7d164">RHGenericDriver</a>.</p>

</div>
</div>
<a id="af82a441a5946b538f60f31e727009750" name="af82a441a5946b538f60f31e727009750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a441a5946b538f60f31e727009750">&#9670;&nbsp;</a></span>printRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::printRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints the value of all chip registers to the Serial device if RH_HAVE_SERIAL is defined for the current platform For debugging purposes only. </p><dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a8bca98b1e9abd1c55aaa32d10ea9631b" name="a8bca98b1e9abd1c55aaa32d10ea9631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bca98b1e9abd1c55aaa32d10ea9631b">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::recv </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Turns the receiver on if it not already on. If there is a valid message available, copy it to buf and return true else return false. If a message is copied, *len is set to the length (Caution, 0 length messages are permitted). You should be sure to call this function frequently enough to not miss any messages It is recommended that you call it in your main loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy the received message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pointer to available space in buf. Set to the actual number of octets copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid message was copied to buf </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a58f0f64dff770bbeb1b197a5fca0579a">RHGenericDriver</a>.</p>

</div>
</div>
<a id="ae7d3743511fdcc1b41f5f8e6b0964c1f" name="ae7d3743511fdcc1b41f5f8e6b0964c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d3743511fdcc1b41f5f8e6b0964c1f">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits until any previous transmit packet is finished being transmitted with <a class="el" href="class_r_h_generic_driver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent()</a>. Then optionally waits for Channel Activity Detection (CAD) to show the channnel is clear (if the radio supports CAD) by calling <a class="el" href="class_r_h_generic_driver.html#ac577b932ba8b042b8170b24d513635c7">waitCAD()</a>. Then loads a message into the transmitter and starts the transmitter. Note that a message length of 0 is permitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes of data to send specify the maximum time in ms to wait. If 0 (the default) do not wait for CAD before transmitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message length was valid and it was correctly queued for transmit. Return false if CAD was requested and the CAD timeout timed out before clear channel was detected. </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a5716069edea652af8019daaeb64357ee">RHGenericDriver</a>.</p>

</div>
</div>
<a id="ad7edba1cc8e33512c0b1721758bd0077" name="ad7edba1cc8e33512c0b1721758bd0077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7edba1cc8e33512c0b1721758bd0077">&#9670;&nbsp;</a></span>setCodingRate4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setCodingRate4 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>denominator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a href="#" onclick="location.href='mai'+'lto:'+'bri'+'an'+'.n.'+'no'+'rma'+'n@'+'gma'+'il'+'.co'+'m'; return false;">brian<span class="obfuscator">.nosp@m.</span>.n.n<span class="obfuscator">.nosp@m.</span>orman<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a> 9th Nov 2018 Sets the coding rate to 4/5, 4/6, 4/7 or 4/8. Valid denominator values are 5, 6, 7 or 8. A value of 5 sets the coding rate to 4/5 etc. Values below 5 are clamped at 5 values above 8 are clamped at 8 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">denominator</td><td>uint8_t range 5..8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854c2eaa2f3cf9583453ff09f15e1099" name="a854c2eaa2f3cf9583453ff09f15e1099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854c2eaa2f3cf9583453ff09f15e1099">&#9670;&nbsp;</a></span>setFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the transmitter and receiver centre frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">centre</td><td>Frequency in MHz. 137.0 to 1020.0. Caution: RFM95/96/97/98 comes in several different frequency ranges, and setting a frequency outside that range of your radio will probably not work </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the selected frquency centre is within range </dd></dl>

</div>
</div>
<a id="a8e2df6a6d2cb192b13bd572a7005da67" name="a8e2df6a6d2cb192b13bd572a7005da67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2df6a6d2cb192b13bd572a7005da67">&#9670;&nbsp;</a></span>setLowDatarate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setLowDatarate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a href="#" onclick="location.href='mai'+'lto:'+'bri'+'an'+'.n.'+'no'+'rma'+'n@'+'gma'+'il'+'.co'+'m'; return false;">brian<span class="obfuscator">.nosp@m.</span>.n.n<span class="obfuscator">.nosp@m.</span>orman<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a> 9th Nov 2018 sets the low data rate flag if symbol time exceeds 16ms ref: <a href="https://www.thethingsnetwork.org/forum/t/a-point-to-note-lora-low-data-rate-optimisation-flag/12007">https://www.thethingsnetwork.org/forum/t/a-point-to-note-lora-low-data-rate-optimisation-flag/12007</a> called by setBandwidth() and setSpreadingfactor() since these affect the symbol time. </p>

</div>
</div>
<a id="a44b9fd0c59274f5d0bfcc622757c2eeb" name="a44b9fd0c59274f5d0bfcc622757c2eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b9fd0c59274f5d0bfcc622757c2eeb">&#9670;&nbsp;</a></span>setModeIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setModeIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If current mode is Rx or Tx changes it to Idle. If the transmitter or receiver is running, disables them. </p>

</div>
</div>
<a id="af6f6131a36c2a0f84a5883a6ec7acfec" name="af6f6131a36c2a0f84a5883a6ec7acfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f6131a36c2a0f84a5883a6ec7acfec">&#9670;&nbsp;</a></span>setModemConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::setModemConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_h___r_f95.html#ab9605810c11c025758ea91b2813666e3">ModemConfigChoice</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Select one of the predefined modem configurations. If you need a modem configuration not provided here, use <a class="el" href="class_r_h___r_f95.html#aa191d9634325354102394b856c47b5ba">setModemRegisters()</a> with your own <a class="el" href="struct_r_h___r_f95_1_1_modem_config.html" title="Defines register values for a set of modem configuration registers.">ModemConfig</a>. Caution: the slowest protocols may require a radio module with TCXO temperature controlled oscillator for reliable operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The configuration choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is a valid choice. </dd></dl>

</div>
</div>
<a id="aa191d9634325354102394b856c47b5ba" name="aa191d9634325354102394b856c47b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa191d9634325354102394b856c47b5ba">&#9670;&nbsp;</a></span>setModemRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setModemRegisters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_h___r_f95_1_1_modem_config.html">ModemConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets all the registered required to configure the data modem in the RF95/96/97/98, including the bandwidth, spreading factor etc. You can use this to configure the modem with custom configurations if none of the canned configurations in ModemConfigChoice suit you. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="struct_r_h___r_f95_1_1_modem_config.html" title="Defines register values for a set of modem configuration registers.">ModemConfig</a> structure containing values for the modem configuration registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade668dcd0730fef266c8d94c7e6e7085" name="ade668dcd0730fef266c8d94c7e6e7085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade668dcd0730fef266c8d94c7e6e7085">&#9670;&nbsp;</a></span>setModeRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setModeRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If current mode is Tx or Idle, changes it to Rx. Starts the receiver in the RF95/96/97/98. </p>

</div>
</div>
<a id="a46330e9d7ec87255b91d0e4297cc8814" name="a46330e9d7ec87255b91d0e4297cc8814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46330e9d7ec87255b91d0e4297cc8814">&#9670;&nbsp;</a></span>setModeTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setModeTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If current mode is Rx or Idle, changes it to Rx. F Starts the transmitter in the RF95/96/97/98. </p>

</div>
</div>
<a id="a9b402c77236b0dfe3ec68e953faa02dd" name="a9b402c77236b0dfe3ec68e953faa02dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b402c77236b0dfe3ec68e953faa02dd">&#9670;&nbsp;</a></span>setPayloadCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setPayloadCRC </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a href="#" onclick="location.href='mai'+'lto:'+'bri'+'an'+'.n.'+'no'+'rma'+'n@'+'gma'+'il'+'.co'+'m'; return false;">brian<span class="obfuscator">.nosp@m.</span>.n.n<span class="obfuscator">.nosp@m.</span>orman<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a> 9th Nov 2018 allows the payload CRC bit to be turned on/off. Normally this should be left on so that packets with a bad CRC are rejected \patam[in] on bool, true turns the payload CRC on, false turns it off </p>

</div>
</div>
<a id="af0f16c9b450bdd13a421d282e58a09fb" name="af0f16c9b450bdd13a421d282e58a09fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f16c9b450bdd13a421d282e58a09fb">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the length of the preamble in bytes. Caution: this should be set to the same value on all nodes in your network. Default is 8. Sets the message preamble length in RH_RF95_REG_??_PREAMBLE_?SB </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Preamble length in bytes. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02ba623bba31f200e50e46686ec61176" name="a02ba623bba31f200e50e46686ec61176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ba623bba31f200e50e46686ec61176">&#9670;&nbsp;</a></span>setSignalBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setSignalBandwidth </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sbw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a href="#" onclick="location.href='mai'+'lto:'+'bri'+'an'+'.n.'+'no'+'rma'+'n@'+'gma'+'il'+'.co'+'m'; return false;">brian<span class="obfuscator">.nosp@m.</span>.n.n<span class="obfuscator">.nosp@m.</span>orman<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a> 9th Nov 2018 Sets the radio signal bandwidth sbw ranges and resultant settings are as follows:- sbw range actual bw (kHz) 0-7800 7.8 7801-10400 10.4 10401-15600 15.6 15601-20800 20.8 20801-31250 31.25 31251-41700 41.7 41701-62500 62.5 62501-12500 12.5 12501-250000 250.0 &gt;250000 500.0 NOTE caution Earlier - Semtech do not recommend BW below 62.5 although, in testing I managed 31.25 with two devices in close proximity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sbw</td><td>long, signal bandwidth e.g. 125000 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abea770963212a64b35169f0f0c35c14d" name="abea770963212a64b35169f0f0c35c14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea770963212a64b35169f0f0c35c14d">&#9670;&nbsp;</a></span>setSpreadingFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setSpreadingFactor </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a href="#" onclick="location.href='mai'+'lto:'+'bri'+'an'+'.n.'+'no'+'rma'+'n@'+'gma'+'il'+'.co'+'m'; return false;">brian<span class="obfuscator">.nosp@m.</span>.n.n<span class="obfuscator">.nosp@m.</span>orman<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a> 9th Nov 2018 Sets the radio spreading factor. valid values are 6 through 12. Out of range values below 6 are clamped to 6 Out of range values above 12 are clamped to 12 See Semtech DS SX1276/77/78/79 page 27 regarding SF6 configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uint8_t</td><td>sf (spreading factor 6..12) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a id="ab273e242758e3cc2ed2679ef795a7196" name="ab273e242758e3cc2ed2679ef795a7196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab273e242758e3cc2ed2679ef795a7196">&#9670;&nbsp;</a></span>setTxPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::setTxPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRFO</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the transmitter power output level, and configures the transmitter pin. Be a good neighbour and set the lowest power level you need. Some SX1276/77/78/79 and compatible modules (such as RFM95/96/97/98) use the PA_BOOST transmitter pin for high power output (and optionally the PA_DAC) while some (such as the Modtronix inAir4 and inAir9) use the RFO transmitter pin for lower power but higher efficiency. You must set the appropriate power level and useRFO argument for your module. Check with your module manufacturer which transmtter pin is used on your module to ensure you are setting useRFO correctly. Failure to do so will result in very low transmitter power output. Caution: legal power limits may apply in certain countries. After <a class="el" href="class_r_h___r_f95.html#aa7bee6fb7ad0e0d0ae5e04ed27cfd79d">init()</a>, the power will be set to 13dBm, with useRFO false (ie PA_BOOST enabled). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>Transmitter power level in dBm. For RFM95/96/97/98 LORA with useRFO false, valid values are from +5 to +23. For Modtronix inAir4 and inAir9 with useRFO true (ie RFO pins in use), valid values are from -1 to 14. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useRFO</td><td>If true, enables the use of the RFO transmitter pins instead of the PA_BOOST pin (false). Choose the correct setting for your module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9184ab8aec1c3c54a275d08c7e85c66" name="aa9184ab8aec1c3c54a275d08c7e85c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9184ab8aec1c3c54a275d08c7e85c66">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the radio into low-power sleep mode. If successful, the transport will stay in sleep mode until woken by changing mode it idle, transmit or receive (eg by calling <a class="el" href="class_r_h___r_f95.html#ae7d3743511fdcc1b41f5f8e6b0964c1f">send()</a>, <a class="el" href="class_r_h___r_f95.html#a8bca98b1e9abd1c55aaa32d10ea9631b">recv()</a>, <a class="el" href="class_r_h___r_f95.html#a917a6b16ca2be2da530516220560cf43">available()</a> etc) Caution: there is a time penalty as the radio takes a finite time to wake from sleep mode. </p><dl class="section return"><dt>Returns</dt><dd>true if sleep mode was successfully entered. </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#a97050555cbf46ad723ad9c45d7f76a55">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a09086214734986feeb1e647a7820b615" name="a09086214734986feeb1e647a7820b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09086214734986feeb1e647a7820b615">&#9670;&nbsp;</a></span>validateRxBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF95::validateRxBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examine the revceive buffer to determine whether the message is for this node. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac9b4c17fd74f962a3af6f6a7e7bc4b8a" name="ac9b4c17fd74f962a3af6f6a7e7bc4b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b4c17fd74f962a3af6f6a7e7bc4b8a">&#9670;&nbsp;</a></span>_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF95::_buf[RH_RF95_MAX_PAYLOAD_LEN]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The receiver/transmitter buffer. </p>

</div>
</div>
<a id="aa553f8428e9528dc43a78a983b379110" name="aa553f8428e9528dc43a78a983b379110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa553f8428e9528dc43a78a983b379110">&#9670;&nbsp;</a></span>_bufLen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t RH_RF95::_bufLen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of octets in the buffer. </p>

</div>
</div>
<a id="abb55a3dea7023d199e38c3200c811fe2" name="abb55a3dea7023d199e38c3200c811fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb55a3dea7023d199e38c3200c811fe2">&#9670;&nbsp;</a></span>_deviceForInterrupt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_h___r_f95.html">RH_RF95</a> * RH_RF95::_deviceForInterrupt = {0, 0, 0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of instances connected to interrupts 0 and 1. </p>

</div>
</div>
<a id="a0c6dd8b1fa38a3275501f37a52d78aad" name="a0c6dd8b1fa38a3275501f37a52d78aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6dd8b1fa38a3275501f37a52d78aad">&#9670;&nbsp;</a></span>_interruptCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF95::_interruptCount = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of next interrupt number to use in _deviceForInterrupt. </p>

</div>
</div>
<a id="a9f43cda8dd8d5edc5508937393dfce13" name="a9f43cda8dd8d5edc5508937393dfce13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43cda8dd8d5edc5508937393dfce13">&#9670;&nbsp;</a></span>_interruptPin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF95::_interruptPin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The configured interrupt pin connected to this instance. </p>

</div>
</div>
<a id="a6646ae738f52f7fe9871ce21f4df8f9e" name="a6646ae738f52f7fe9871ce21f4df8f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646ae738f52f7fe9871ce21f4df8f9e">&#9670;&nbsp;</a></span>_lastSNR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RH_RF95::_lastSNR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a358c2394e5b1e52aa15adbff92b3e229" name="a358c2394e5b1e52aa15adbff92b3e229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358c2394e5b1e52aa15adbff92b3e229">&#9670;&nbsp;</a></span>_myInterruptIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF95::_myInterruptIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The index into _deviceForInterrupt[] for this device (if an interrupt is already allocated) else 0xff </p>

</div>
</div>
<a id="a03d4a80e90eb918841c2e63d79536f5d" name="a03d4a80e90eb918841c2e63d79536f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d4a80e90eb918841c2e63d79536f5d">&#9670;&nbsp;</a></span>_rxBufValid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool RH_RF95::_rxBufValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True when there is a valid message in the buffer. </p>

</div>
</div>
<a id="a430db47e388aba6f7690abe017aa7e58" name="a430db47e388aba6f7690abe017aa7e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430db47e388aba6f7690abe017aa7e58">&#9670;&nbsp;</a></span>_usingHFport</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF95::_usingHFport</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_h___r_f95_8h_source.html">RH_RF95.h</a></li>
<li><a class="el" href="_r_h___r_f95_8cpp.html">RH_RF95.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath">
    <!-- id is needed for treeview function! -->
    <ul>
        <li class="navelem"><a class="el" href="class_r_h___r_f95.html">RH_RF95</a></li>
        <li class="footer">
            Generated on Thu Feb 24 2022 13:59:53 for Soldered RF433 Arduino Library by <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"
                    onerror="this.onerror=null;this.src='doxygen.svg';" /></a> 1.9.3.
            Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
            Copyright: <a href="https://www.soldered.com">Soldered</a>
        </li>
    </ul>
</div>
<script src="custom.js"></script>
</body>
</html>
