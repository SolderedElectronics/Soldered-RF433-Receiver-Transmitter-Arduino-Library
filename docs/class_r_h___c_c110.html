<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Soldered RF433 Arduino Library: RH_CC110 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Soldered RF433 Arduino Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">This is a Soldered RF433 Arduino Module</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_r_h___c_c110.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_r_h___c_c110-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RH_CC110 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transceivers and modules.  
 <a href="class_r_h___c_c110.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_r_h___c_c110_8h_source.html">RH_CC110.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_r_h_n_r_f_s_p_i_driver.html">RHNRFSPIDriver</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_h___c_c110_1_1_modem_config.html">ModemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines register configuration values for a desired modulation.  <a href="struct_r_h___c_c110_1_1_modem_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac208a5ea5ced06bafa203e4a57e0ec26"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26">ModemConfigChoice</a> { <br />
&#160;&#160;<a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26a17a28b581e46e8c0c2a20fd96ef0dcfc">GFSK_Rb1_2Fd5_2</a> = 0
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26ab8787d83919cc8d2adae8bcb53e90805">GFSK_Rb2_4Fd5_2</a>
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26aac39a0084e208c162cf1a263a66996d2">GFSK_Rb4_8Fd25_4</a>
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26affd760557e6bc6c112a4a309297fb4fa">GFSK_Rb10Fd19</a>
, <br />
&#160;&#160;<a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26aa78bd11a651953b6ad2d6599b006ad5c">GFSK_Rb38_4Fd20</a>
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26a4fd932d6cbdec4a2c408251a1b68e962">GFSK_Rb76_8Fd32</a>
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26ad4d226c9c8735ae34c09c93243ec94e2">GFSK_Rb100Fd47</a>
, <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26a327e9bf823c6e30c76dd5f63c377c928">GFSK_Rb250Fd127</a>
<br />
 }</td></tr>
<tr class="separator:ac208a5ea5ced06bafa203e4a57e0ec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac34a40d040dad3e64a2e1247e9e1b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9">TransmitPower</a> { <br />
&#160;&#160;<a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a49181777000e838d49cbaea98777e1d3">TransmitPowerM30dBm</a> = 0
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9ade2590f76d84bf984b46b21cfe0acf2d">TransmitPowerM20dBm</a>
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a5b0a18513bed5cfb24916492592246c1">TransmitPowerM15dBm</a>
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a2901fc17652a7cc1d42e0fb7e472d2eb">TransmitPowerM10dBm</a>
, <br />
&#160;&#160;<a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a292de01e04abfbcb9dab83c64e7183b1">TransmitPower0dBm</a>
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a1469abcfb3929abdb7215c2a8a415a17">TransmitPower5dBm</a>
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9aa742fb6879652ea2c684ffc6cff756f8">TransmitPower7dBm</a>
, <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9a35452211ca84528513441b67efd80bbb">TransmitPower10dBm</a>
<br />
 }</td></tr>
<tr class="separator:abac34a40d040dad3e64a2e1247e9e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a7c96558708f18937bc2fa7341f217937 inherit pub_types_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> { <br />
&#160;&#160;<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937ad901fedd5b99db75c942023971632c43">RHModeInitialising</a> = 0
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHModeSleep</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHModeIdle</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHModeTx</a>
, <br />
&#160;&#160;<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHModeRx</a>
, <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937a36997733490b61f1997529c8cfeb4211">RHModeCad</a>
<br />
 }</td></tr>
<tr class="memdesc:a7c96558708f18937bc2fa7341f217937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different operating modes for the transport hardware.  <a href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">More...</a><br /></td></tr>
<tr class="separator:a7c96558708f18937bc2fa7341f217937 inherit pub_types_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3af317709d0c1298c5266c00f3d8281"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af3af317709d0c1298c5266c00f3d8281">RH_CC110</a> (uint8_t slaveSelectPin=SS, uint8_t interruptPin=2, bool is27MHz=false, <a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;spi=<a class="el" href="_r_h_hardware_s_p_i_8cpp.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a>)</td></tr>
<tr class="separator:af3af317709d0c1298c5266c00f3d8281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06c990d7c776dcac9e6ba1dc7a1ff2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init</a> ()</td></tr>
<tr class="separator:a8d06c990d7c776dcac9e6ba1dc7a1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68f6f40ea8f4583126423b59bc2d72a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#ae68f6f40ea8f4583126423b59bc2d72a">printRegisters</a> ()</td></tr>
<tr class="separator:ae68f6f40ea8f4583126423b59bc2d72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef87c720bf127b473e08d2cb540c32b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#afef87c720bf127b473e08d2cb540c32b">waitPacketSent</a> ()</td></tr>
<tr class="separator:afef87c720bf127b473e08d2cb540c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af097fa9c1e8136c8dceec3400a016cbe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af097fa9c1e8136c8dceec3400a016cbe">available</a> ()</td></tr>
<tr class="separator:af097fa9c1e8136c8dceec3400a016cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d6222531343bc248b761a033f14fd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af0d6222531343bc248b761a033f14fd1">recv</a> (uint8_t *buf, uint8_t *len)</td></tr>
<tr class="separator:af0d6222531343bc248b761a033f14fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bcc9f798ccdbce077dadee203140e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a322bcc9f798ccdbce077dadee203140e">send</a> (const uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:a322bcc9f798ccdbce077dadee203140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9f621286a3da2110fd88f75ba996d"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a16b9f621286a3da2110fd88f75ba996d">maxMessageLength</a> ()</td></tr>
<tr class="separator:a16b9f621286a3da2110fd88f75ba996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6682a3683087941a6fbb449500e15070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a6682a3683087941a6fbb449500e15070">setModeIdle</a> ()</td></tr>
<tr class="separator:a6682a3683087941a6fbb449500e15070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88e69f00f69c414b08870a9c077a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#aab88e69f00f69c414b08870a9c077a9d">setModeRx</a> ()</td></tr>
<tr class="separator:aab88e69f00f69c414b08870a9c077a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12356a202823b54f7bc5b3567738a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af12356a202823b54f7bc5b3567738a48">setModeTx</a> ()</td></tr>
<tr class="separator:af12356a202823b54f7bc5b3567738a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9e12b3206e733d8e200547211781ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#aab9e12b3206e733d8e200547211781ea">sleep</a> ()</td></tr>
<tr class="separator:aab9e12b3206e733d8e200547211781ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e2ccd99a4fc47d3ec273ba7927e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#ab95e2ccd99a4fc47d3ec273ba7927e62">setTxPower</a> (<a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9">TransmitPower</a> power)</td></tr>
<tr class="separator:ab95e2ccd99a4fc47d3ec273ba7927e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98881aa331c7ba645464b97aaf42905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#ae98881aa331c7ba645464b97aaf42905">setIs27MHz</a> (bool is27MHz=true)</td></tr>
<tr class="separator:ae98881aa331c7ba645464b97aaf42905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bdb511a4491a4010145518782a346d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af5bdb511a4491a4010145518782a346d">setFrequency</a> (float centre)</td></tr>
<tr class="separator:af5bdb511a4491a4010145518782a346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0ea46f235abc91130511fc461f8907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a5f0ea46f235abc91130511fc461f8907">setModemRegisters</a> (const <a class="el" href="struct_r_h___c_c110_1_1_modem_config.html">ModemConfig</a> *config)</td></tr>
<tr class="separator:a5f0ea46f235abc91130511fc461f8907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4e4637247be0e3d2e9ada303ea15f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a79e4e4637247be0e3d2e9ada303ea15f">setModemConfig</a> (<a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26">ModemConfigChoice</a> index)</td></tr>
<tr class="separator:a79e4e4637247be0e3d2e9ada303ea15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba36c862098176950fc152e41eda374c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#aba36c862098176950fc152e41eda374c">setSyncWords</a> (const uint8_t *syncWords, uint8_t len)</td></tr>
<tr class="separator:aba36c862098176950fc152e41eda374c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae97a2582b984fe078a5c85cb03fd2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#aae97a2582b984fe078a5c85cb03fd2bc">setPaTable</a> (uint8_t *patable, uint8_t patablesize)</td></tr>
<tr class="separator:aae97a2582b984fe078a5c85cb03fd2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_h_n_r_f_s_p_i_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_h_n_r_f_s_p_i_driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_h_n_r_f_s_p_i_driver.html">RHNRFSPIDriver</a></td></tr>
<tr class="memitem:ad29885db2f76ad430663109ca974697f inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#ad29885db2f76ad430663109ca974697f">RHNRFSPIDriver</a> (uint8_t slaveSelectPin=SS, <a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;spi=<a class="el" href="_r_h_hardware_s_p_i_8cpp.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a>)</td></tr>
<tr class="separator:ad29885db2f76ad430663109ca974697f inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c129520de4cfc0782c2c414515ebac7 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a0c129520de4cfc0782c2c414515ebac7">init</a> ()</td></tr>
<tr class="separator:a0c129520de4cfc0782c2c414515ebac7 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac994fd07e90af20098e07dc309f8a inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a91ac994fd07e90af20098e07dc309f8a">spiCommand</a> (uint8_t command)</td></tr>
<tr class="separator:a91ac994fd07e90af20098e07dc309f8a inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4013b6ad1f9bda878b3a87b1205d5 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a10b4013b6ad1f9bda878b3a87b1205d5">spiRead</a> (uint8_t reg)</td></tr>
<tr class="separator:a10b4013b6ad1f9bda878b3a87b1205d5 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4795454482baa5a2c4df6e89c97b19b3 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a4795454482baa5a2c4df6e89c97b19b3">spiWrite</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a4795454482baa5a2c4df6e89c97b19b3 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395f4af2d6dbb62ea62c74b1377f490a inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a395f4af2d6dbb62ea62c74b1377f490a">spiBurstRead</a> (uint8_t reg, uint8_t *dest, uint8_t len)</td></tr>
<tr class="separator:a395f4af2d6dbb62ea62c74b1377f490a inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf701d926af0e7c5d64b676b11b3905c inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#aaf701d926af0e7c5d64b676b11b3905c">spiBurstWrite</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:aaf701d926af0e7c5d64b676b11b3905c inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6815d6c619e53d15e0dfc3794740ac3 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#af6815d6c619e53d15e0dfc3794740ac3">setSlaveSelectPin</a> (uint8_t slaveSelectPin)</td></tr>
<tr class="separator:af6815d6c619e53d15e0dfc3794740ac3 inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb936e79c58820dce8641666cce418b inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#aacb936e79c58820dce8641666cce418b">spiUsingInterrupt</a> (uint8_t interruptNumber)</td></tr>
<tr class="separator:aacb936e79c58820dce8641666cce418b inherit pub_methods_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aacf1b301be4cc16800a62632df6fdd37">RHGenericDriver</a> ()</td></tr>
<tr class="memdesc:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1cfcd4d6187702c364cf4c81e76365 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3e1cfcd4d6187702c364cf4c81e76365">init</a> ()</td></tr>
<tr class="separator:a3e1cfcd4d6187702c364cf4c81e76365 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd522b8eb16c51dc948b4ca4d623888 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2dd522b8eb16c51dc948b4ca4d623888">available</a> ()=0</td></tr>
<tr class="separator:a2dd522b8eb16c51dc948b4ca4d623888 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f0f64dff770bbeb1b197a5fca0579a inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a58f0f64dff770bbeb1b197a5fca0579a">recv</a> (uint8_t *buf, uint8_t *len)=0</td></tr>
<tr class="separator:a58f0f64dff770bbeb1b197a5fca0579a inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716069edea652af8019daaeb64357ee inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5716069edea652af8019daaeb64357ee">send</a> (const uint8_t *data, uint8_t len)=0</td></tr>
<tr class="separator:a5716069edea652af8019daaeb64357ee inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267459de4eb3032c5efb8b220af7d164 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a267459de4eb3032c5efb8b220af7d164">maxMessageLength</a> ()=0</td></tr>
<tr class="separator:a267459de4eb3032c5efb8b220af7d164 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf108e52389353cb3658b6802b92c77c inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf108e52389353cb3658b6802b92c77c">waitAvailable</a> ()</td></tr>
<tr class="separator:abf108e52389353cb3658b6802b92c77c inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent</a> ()</td></tr>
<tr class="separator:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a0feda1f5522522dc50e0c26dcdef71dd">waitPacketSent</a> (uint16_t timeout)</td></tr>
<tr class="separator:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a8ed545cecc22196a325333dc9637e4cf">waitAvailableTimeout</a> (uint16_t timeout)</td></tr>
<tr class="separator:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#ac577b932ba8b042b8170b24d513635c7">waitCAD</a> ()</td></tr>
<tr class="separator:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a445039899f159c02bf6e642e3e12d9b9">setCADTimeout</a> (unsigned long cad_timeout)</td></tr>
<tr class="separator:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#af4bc85a58ebc777ea1f3b57f3ae87b1b">isChannelActive</a> ()</td></tr>
<tr class="separator:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5e8f15e1e7480899d18c3a21248bb628">setThisAddress</a> (uint8_t thisAddress)</td></tr>
<tr class="separator:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a182436232f7a345bca0d1766d242f3fb">setHeaderTo</a> (uint8_t to)</td></tr>
<tr class="separator:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a470e67f4168dec41435dcc0e194202c8">setHeaderFrom</a> (uint8_t from)</td></tr>
<tr class="separator:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a4dd57079264bda98bc89145fe5d2eb8f">setHeaderId</a> (uint8_t id)</td></tr>
<tr class="separator:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#acb992b3c5e360e68b67e4843558bcf3b">setHeaderFlags</a> (uint8_t set, uint8_t clear=RH_FLAGS_APPLICATION_SPECIFIC)</td></tr>
<tr class="separator:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2791f57538b02a73e7dbe1031048230e">setPromiscuous</a> (bool promiscuous)</td></tr>
<tr class="separator:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a6f49c9fe68354b50988dec435fa8d086">headerTo</a> ()</td></tr>
<tr class="separator:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a8cf7a972186592c51c6fde034d17ab9f">headerFrom</a> ()</td></tr>
<tr class="separator:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a81548960bb29a3ac35325c74cd562f45">headerId</a> ()</td></tr>
<tr class="separator:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a056fbd2df558971fe8a1653499a37c63">headerFlags</a> ()</td></tr>
<tr class="separator:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi</a> ()</td></tr>
<tr class="separator:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a> ()</td></tr>
<tr class="separator:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#aa1c0a94ba6414b5bbab0133c4d74e646">setMode</a> (<a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> <a class="el" href="class_r_h_generic_driver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a>)</td></tr>
<tr class="memdesc:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operating mode of the transport.  <br /></td></tr>
<tr class="separator:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97050555cbf46ad723ad9c45d7f76a55 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a97050555cbf46ad723ad9c45d7f76a55">sleep</a> ()</td></tr>
<tr class="separator:a97050555cbf46ad723ad9c45d7f76a55 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a0163fb71dc8d0cd86136882886adba7f">rxBad</a> ()</td></tr>
<tr class="separator:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5f730e644ab1f5f529fdfa82fdb2ed69">rxGood</a> ()</td></tr>
<tr class="separator:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a66a408f88a1188a0fab458816cb705f4">txGood</a> ()</td></tr>
<tr class="separator:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a598c51161ec8c0ace7db2a5e93b33c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a598c51161ec8c0ace7db2a5e93b33c85">handleInterrupt</a> ()</td></tr>
<tr class="separator:a598c51161ec8c0ace7db2a5e93b33c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4cc83f2a3df61dc6c82c96ee3e0c89"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#ade4cc83f2a3df61dc6c82c96ee3e0c89">spiReadRegister</a> (uint8_t reg)</td></tr>
<tr class="separator:ade4cc83f2a3df61dc6c82c96ee3e0c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7ff7cb91bf6f2f210049629640d840"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a2b7ff7cb91bf6f2f210049629640d840">spiBurstReadRegister</a> (uint8_t reg)</td></tr>
<tr class="separator:a2b7ff7cb91bf6f2f210049629640d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2366878f8093ac2adb5c3c951ad79001"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a2366878f8093ac2adb5c3c951ad79001">spiWriteRegister</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a2366878f8093ac2adb5c3c951ad79001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe64dd011a064b6d2253170fcd40b4f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#abbe64dd011a064b6d2253170fcd40b4f">spiBurstWriteRegister</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:abbe64dd011a064b6d2253170fcd40b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c85807541d9e78a01a33992e8799bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a80c85807541d9e78a01a33992e8799bb">validateRxBuf</a> ()</td></tr>
<tr class="separator:a80c85807541d9e78a01a33992e8799bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb6c2ccb795f6132073a4cdd0350d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a22fb6c2ccb795f6132073a4cdd0350d2">clearRxBuf</a> ()</td></tr>
<tr class="memdesc:a22fb6c2ccb795f6132073a4cdd0350d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear our local receive buffer.  <br /></td></tr>
<tr class="separator:a22fb6c2ccb795f6132073a4cdd0350d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4a41f2217a70082084b21110442336"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a9e4a41f2217a70082084b21110442336">statusRead</a> ()</td></tr>
<tr class="separator:a9e4a41f2217a70082084b21110442336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2a825fd587ed025d710ce31d7ba4c10c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a2a825fd587ed025d710ce31d7ba4c10c">isr0</a> ()</td></tr>
<tr class="memdesc:a2a825fd587ed025d710ce31d7ba4c10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 0.  <br /></td></tr>
<tr class="separator:a2a825fd587ed025d710ce31d7ba4c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a72de8a53a3d524ddf76e02d900f32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#af5a72de8a53a3d524ddf76e02d900f32">isr1</a> ()</td></tr>
<tr class="memdesc:af5a72de8a53a3d524ddf76e02d900f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 1.  <br /></td></tr>
<tr class="separator:af5a72de8a53a3d524ddf76e02d900f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3058990fcd92a8a770b05c5970ad3a20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a3058990fcd92a8a770b05c5970ad3a20">isr2</a> ()</td></tr>
<tr class="memdesc:a3058990fcd92a8a770b05c5970ad3a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for device connected to interrupt 1.  <br /></td></tr>
<tr class="separator:a3058990fcd92a8a770b05c5970ad3a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a38710fe45f29692c3a3b1f660662b243"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a38710fe45f29692c3a3b1f660662b243">_interruptPin</a></td></tr>
<tr class="memdesc:a38710fe45f29692c3a3b1f660662b243"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured interrupt pin connected to this instance.  <br /></td></tr>
<tr class="separator:a38710fe45f29692c3a3b1f660662b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cf5fa5a1cc3691a824d011c9545b5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a344cf5fa5a1cc3691a824d011c9545b5">_myInterruptIndex</a></td></tr>
<tr class="separator:a344cf5fa5a1cc3691a824d011c9545b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030a786595bb5a4116fa4ad8fd284d3c"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a030a786595bb5a4116fa4ad8fd284d3c">_bufLen</a></td></tr>
<tr class="memdesc:a030a786595bb5a4116fa4ad8fd284d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of octets in the buffer.  <br /></td></tr>
<tr class="separator:a030a786595bb5a4116fa4ad8fd284d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b87dbcff0d87475b81924311992504"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a83b87dbcff0d87475b81924311992504">_buf</a> [RH_CC110_MAX_PAYLOAD_LEN]</td></tr>
<tr class="memdesc:a83b87dbcff0d87475b81924311992504"><td class="mdescLeft">&#160;</td><td class="mdescRight">The receiver/transmitter buffer.  <br /></td></tr>
<tr class="separator:a83b87dbcff0d87475b81924311992504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253759c4ae98449b11555206bfb9e30d"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a253759c4ae98449b11555206bfb9e30d">_rxBufValid</a></td></tr>
<tr class="memdesc:a253759c4ae98449b11555206bfb9e30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True when there is a valid message in the buffer.  <br /></td></tr>
<tr class="separator:a253759c4ae98449b11555206bfb9e30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c2d5f5ee84926f5f675b8425137757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a98c2d5f5ee84926f5f675b8425137757">_is27MHz</a></td></tr>
<tr class="memdesc:a98c2d5f5ee84926f5f675b8425137757"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if crystal oscillator is 26 MHz, not 26MHz.  <br /></td></tr>
<tr class="separator:a98c2d5f5ee84926f5f675b8425137757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a53e2a54933fc10a505bb4a5f6f4aabd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_r_h___c_c110.html">RH_CC110</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a53e2a54933fc10a505bb4a5f6f4aabd2">_deviceForInterrupt</a> [] = {0, 0, 0}</td></tr>
<tr class="memdesc:a53e2a54933fc10a505bb4a5f6f4aabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instances connected to interrupts 0 and 1.  <br /></td></tr>
<tr class="separator:a53e2a54933fc10a505bb4a5f6f4aabd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbe0a46650a2e12a94bd9b0e6c76dba"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h___c_c110.html#a7bbe0a46650a2e12a94bd9b0e6c76dba">_interruptCount</a> = 0</td></tr>
<tr class="memdesc:a7bbe0a46650a2e12a94bd9b0e6c76dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of next interrupt number to use in _deviceForInterrupt.  <br /></td></tr>
<tr class="separator:a7bbe0a46650a2e12a94bd9b0e6c76dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a63915f6420833eb8ec61ee3b0610e34b">printBuffer</a> (const char *prompt, const uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_r_h_n_r_f_s_p_i_driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_r_h_n_r_f_s_p_i_driver.html">RHNRFSPIDriver</a></td></tr>
<tr class="memitem:a9bc1811477d8a9b046fc1594b09fdbc2 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a9bc1811477d8a9b046fc1594b09fdbc2">_spi</a></td></tr>
<tr class="memdesc:a9bc1811477d8a9b046fc1594b09fdbc2 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the <a class="el" href="class_r_h_generic_s_p_i.html" title="Base class for SPI interfaces.">RHGenericSPI</a> instance to use to trasnfer data with teh SPI device.  <br /></td></tr>
<tr class="separator:a9bc1811477d8a9b046fc1594b09fdbc2 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf895ccfcf62c4fc7268fdc4c79c889 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_n_r_f_s_p_i_driver.html#a4cf895ccfcf62c4fc7268fdc4c79c889">_slaveSelectPin</a></td></tr>
<tr class="memdesc:a4cf895ccfcf62c4fc7268fdc4c79c889 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pin number of the Slave Select pin that is used to select the desired device.  <br /></td></tr>
<tr class="separator:a4cf895ccfcf62c4fc7268fdc4c79c889 inherit pro_attribs_class_r_h_n_r_f_s_p_i_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_r_h_generic_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_r_h_generic_driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_r_h_generic_driver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="class_r_h_generic_driver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a324854a5f898b0a48ec83424351730c5">_mode</a></td></tr>
<tr class="memdesc:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current transport operating mode.  <br /></td></tr>
<tr class="separator:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a6d2e9824e29c9d5e9ad28682e53ea974">_thisAddress</a></td></tr>
<tr class="memdesc:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node id.  <br /></td></tr>
<tr class="separator:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2d94c93203714ed3dd9a7434101683e9">_promiscuous</a></td></tr>
<tr class="memdesc:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transport is in promiscuous mode.  <br /></td></tr>
<tr class="separator:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abff3740bc072a2d435194a7860b2bfe3">_rxHeaderTo</a></td></tr>
<tr class="memdesc:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header in the last received mesasge.  <br /></td></tr>
<tr class="separator:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a7283cfec4e7c1ecf074307534592fd8f">_rxHeaderFrom</a></td></tr>
<tr class="memdesc:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header in the last received mesasge.  <br /></td></tr>
<tr class="separator:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3155557c35198acdde0ecdf58a201b19">_rxHeaderId</a></td></tr>
<tr class="memdesc:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header in the last received mesasge.  <br /></td></tr>
<tr class="separator:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">_rxHeaderFlags</a></td></tr>
<tr class="memdesc:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header in the last received mesasge.  <br /></td></tr>
<tr class="separator:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a759debcdbdb837cea024f777020203e5">_txHeaderTo</a></td></tr>
<tr class="memdesc:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header to send in all messages.  <br /></td></tr>
<tr class="separator:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">_txHeaderFrom</a></td></tr>
<tr class="memdesc:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header to send in all messages.  <br /></td></tr>
<tr class="separator:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#ad0eafb5a8316b90ad8cd9d42234517da">_txHeaderId</a></td></tr>
<tr class="memdesc:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header to send in all messages.  <br /></td></tr>
<tr class="separator:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf4db9bddfee361cc44fbf4bd22202bc">_txHeaderFlags</a></td></tr>
<tr class="memdesc:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header to send in all messages.  <br /></td></tr>
<tr class="separator:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a9b67eea20e8f9a688d61a5a6b6b2be03">_lastRssi</a></td></tr>
<tr class="memdesc:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the last received RSSI value, in some transport specific units.  <br /></td></tr>
<tr class="separator:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3bafd8dc638309a473367c4ff8e59c0e">_rxBad</a></td></tr>
<tr class="memdesc:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (eg bad checksum etc) received.  <br /></td></tr>
<tr class="separator:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">_rxGood</a></td></tr>
<tr class="memdesc:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of successfully transmitted messaged.  <br /></td></tr>
<tr class="separator:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a5f71653ad58e35ddca7fe3e052674ca2">_txGood</a></td></tr>
<tr class="memdesc:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (correct checksum etc) received.  <br /></td></tr>
<tr class="separator:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a028f651c56df90b8b9d852e16ac3356e">_cad</a></td></tr>
<tr class="memdesc:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity detected.  <br /></td></tr>
<tr class="separator:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_h_generic_driver.html#a3e86bc833626b8255fbc43917932d0d6">_cad_timeout</a></td></tr>
<tr class="memdesc:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity timeout in ms.  <br /></td></tr>
<tr class="separator:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_class_r_h_generic_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transceivers and modules. </p>
<p>The TI CC110L is a low cost tranceiver chip capable of 300 to 928MHz and with a wide range of modulation types and speeds. The chip is typically provided on a module that also includes the antenna and coupling hardware and is therefore capable of a more restricted frequency range.</p>
<p>Supported modules include:</p><ul>
<li>Anaren AIR BoosterPack 430BOOST-CC110L</li>
</ul>
<p>This base class provides basic functions for sending and receiving unaddressed, unreliable datagrams of arbitrary length to 59 octets per packet at a selected data rate and modulation type. Use one of the Manager classes to get addressing and acknowledgement reliability, routing, meshes etc.</p>
<p>Naturally, for any 2 radios to communicate that must be configured to use the same frequency and data rate, and with identical network addresses.</p>
<p>Several CC110L modules can be connected to an Arduino, permitting the construction of translators and frequency changers, etc.</p>
<p>Several GFSK modulation schemes are provided and may be selected by calling <a class="el" href="class_r_h___c_c110.html#a79e4e4637247be0e3d2e9ada303ea15f">setModemConfig()</a>. No FSK or OOK modulation schemes are provided though the implementor may configure the mnodem characteristics directly by calling <a class="el" href="class_r_h___c_c110.html#a5f0ea46f235abc91130511fc461f8907">setModemRegisters()</a>.</p>
<p>Implementation based on: <a href="http://www.ti.com/lit/ds/symlink/cc110l.pdf">http://www.ti.com/lit/ds/symlink/cc110l.pdf</a> and <a href="https://www.anaren.com/air/cc110l-air-module-boosterpack-embedded-antenna-module-anaren">https://www.anaren.com/air/cc110l-air-module-boosterpack-embedded-antenna-module-anaren</a></p>
<dl class="section user"><dt>Crystal Frequency</dt><dd></dd></dl>
<p>Modules based on the CC110L may contain a crystal oscillator with one of 2 possible frequencies: 26MHz or 27MHz. A number of radio configuration parameters (including carrier frequency and data rates) depend on the crystal oscillator frequency. The chip has no knowledge of the frequency, so it is up to the implementer to tell the driver the oscillator frequency by passing in the appropriate value of is27MHz to the constructor (default 26MHz) or by calling <a class="el" href="class_r_h___c_c110.html#ae98881aa331c7ba645464b97aaf42905">setIs27MHz()</a> before calling <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a>. Failure to correctly set this flag will cause incorrect frequency and modulation characteristics to be used.</p>
<p>Caution: it is not easy to determine what the actual crystal frequency is on some modules. For example, the documentation for the Anaren BoosterPack indictes a 26MHz crystal, but measurements on the devices delivered here indicate a 27MHz crystal is actually installed. TI recommend 27MHz for</p>
<dl class="section user"><dt>Packet Format</dt><dd></dd></dl>
<ul>
<li>2 octets sync (a configurable network address)</li>
<li>1 octet message length</li>
<li>4 to 63 octets of payload consisting of:<ul>
<li>1 octet TO header</li>
<li>1 octet FROM header</li>
<li>1 octet ID header</li>
<li>1 octet FLAGS header</li>
<li>0 to 59 octets of user message</li>
</ul>
</li>
<li>2 octets CRC</li>
</ul>
<dl class="section user"><dt>Connecting CC110L to Arduino</dt><dd></dd></dl>
<p>Warning: the CC110L is a 3.3V part, and exposing it to 5V on any pin will damage it. Ensure you are using a 3.3V MCU or use level shifters. We tested with Teensy 3.1.</p>
<p>The electrical connection between a CC110L module and the Arduino or other processor require 3.3V, the 3 x SPI pins (SCK, SDI, SDO), a Chip Select pin and an Interrupt pin. Examples below assume the Anaren BoosterPack. Caution: the pin numbering on the Anaren BoosterPack is a bit counter-intuitive: the direction of number on J1 is the reverse of J2. Check the pin numbers stenciled on the front of the board to be sure.</p>
<div class="fragment"><div class="line">         Teensy 3.1   CC110L pin name         Anaren BoosterPack pin</div>
<div class="line">         3.3V---------VDD   (3.3V in)              J1-1</div>
<div class="line">  SS pin D10----------CSn   (chip select in)       J2-8</div>
<div class="line"> SCK pin D13----------SCLK  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> clock in)         J1-7</div>
<div class="line">MOSI pin D11----------MOSI  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> data in)          J2-5</div>
<div class="line">MISO pin D12----------MISO  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> data out)         J2-4</div>
<div class="line">         D2-----------GDO0  (Interrupt output)     J2-9</div>
<div class="line">         GND----------GND   (ground in)            J2-10</div>
<div class="ttc" id="a_r_h_hardware_s_p_i_8cpp_html_a5957ea19a6d6c4732ad338e86ff49ecb"><div class="ttname"><a href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a></div><div class="ttdeci">HardwareSPI SPI(1)</div></div>
</div><!-- fragment --><p> and use the default <a class="el" href="class_r_h___c_c110.html" title="Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transc...">RH_CC110</a> constructor. You can use other pins by passing the appropriate arguments to the <a class="el" href="class_r_h___c_c110.html" title="Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transc...">RH_CC110</a> constructor, depending on what your MCU supports.</p>
<p>For the Particle Photon: </p><div class="fragment"><div class="line">         Photon   CC110L pin name         Anaren BoosterPack pin</div>
<div class="line">         3.3V---------VDD   (3.3V in)              J1-1</div>
<div class="line">  SS pin A2-----------CSn   (chip select in)       J2-8</div>
<div class="line"> SCK pin A3-----------SCLK  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> clock in)         J1-7</div>
<div class="line">MOSI pin A5-----------MOSI  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> data in)          J2-5</div>
<div class="line">MISO pin A4-----------MISO  (<a class="code hl_variable" href="_r_h_hardware_s_p_i_8cpp.html#a5957ea19a6d6c4732ad338e86ff49ecb">SPI</a> data out)         J2-4</div>
<div class="line">         D2-----------GDO0  (Interrupt output)     J2-9</div>
<div class="line">         GND----------GND   (ground in)            J2-10</div>
</div><!-- fragment --><p> and use the default <a class="el" href="class_r_h___c_c110.html" title="Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transc...">RH_CC110</a> constructor. You can use other pins by passing the appropriate arguments to the <a class="el" href="class_r_h___c_c110.html" title="Send and receive unaddressed, unreliable, datagrams by Texas Instruments CC110L and compatible transc...">RH_CC110</a> constructor, depending on what your MCU supports.</p>
<dl class="section user"><dt>Example programs</dt><dd></dd></dl>
<p>Several example programs are provided.</p>
<dl class="section user"><dt>Radio operating strategy and defaults</dt><dd></dd></dl>
<p>The radio is enabled at all times and switched between RX, TX and IDLE modes. When RX is enabled (by calling <a class="el" href="class_r_h___c_c110.html#af097fa9c1e8136c8dceec3400a016cbe">available()</a> or <a class="el" href="class_r_h___c_c110.html#aab88e69f00f69c414b08870a9c077a9d">setModeRx()</a>) the radio will stay in RX mode until a valid CRC correct message addressed to thiis node is received, when it will transition to IDLE. When TX is enabled (by calling <a class="el" href="class_r_h___c_c110.html#a322bcc9f798ccdbce077dadee203140e">send()</a>) it will stay in TX mode until the message has ben sent and <a class="el" href="class_r_h___c_c110.html#afef87c720bf127b473e08d2cb540c32b">waitPacketSent()</a> is called when it wil transition to IDLE (this radio has no 'packet sent' interrupt that could be used, so polling with <a class="el" href="class_r_h___c_c110.html#afef87c720bf127b473e08d2cb540c32b">waitPacketSent()</a> is required</p>
<p>The modulation schemes supported include the GFSK schemes provided by default in the TI SmartRF Suite. This software allows you to get the correct register values for diferent modulation schemes. All the modulation schemes prvided in the driver are based on the recommended register values given by SmartRF. Other schemes such a 2-FSK, 4-FSK and OOK are suported by the chip, but canned configurations are not provided with this driver. The implementer may choose to create their own modem configurations and pass them to <a class="el" href="class_r_h___c_c110.html#a5f0ea46f235abc91130511fc461f8907">setModemRegisters()</a>. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac208a5ea5ced06bafa203e4a57e0ec26" name="ac208a5ea5ced06bafa203e4a57e0ec26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac208a5ea5ced06bafa203e4a57e0ec26">&#9670;&#160;</a></span>ModemConfigChoice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26">RH_CC110::ModemConfigChoice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choices for <a class="el" href="class_r_h___c_c110.html#a79e4e4637247be0e3d2e9ada303ea15f">setModemConfig()</a> for a selected subset of common modulation types, and data rates. If you need another configuration, use the register calculator. and call <a class="el" href="class_r_h___c_c110.html#a5f0ea46f235abc91130511fc461f8907">setModemRegisters()</a> with your desired settings. These are indexes into MODEM_CONFIG_TABLE. We strongly recommend you use these symbolic definitions and not their integer equivalents: its possible that new values will be introduced in later versions (though we will try to avoid it). All configs use SYNC_MODE = RH_CC110_SYNC_MODE_16_16 (2 byte sync) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26a17a28b581e46e8c0c2a20fd96ef0dcfc" name="ac208a5ea5ced06bafa203e4a57e0ec26a17a28b581e46e8c0c2a20fd96ef0dcfc"></a>GFSK_Rb1_2Fd5_2&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 1.2kBaud, Dev: 5.2kHz, RX BW 58kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26ab8787d83919cc8d2adae8bcb53e90805" name="ac208a5ea5ced06bafa203e4a57e0ec26ab8787d83919cc8d2adae8bcb53e90805"></a>GFSK_Rb2_4Fd5_2&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 2.4kBaud, Dev: 5.2kHz, RX BW 58kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26aac39a0084e208c162cf1a263a66996d2" name="ac208a5ea5ced06bafa203e4a57e0ec26aac39a0084e208c162cf1a263a66996d2"></a>GFSK_Rb4_8Fd25_4&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 4.8kBaud, Dev: 25.4kHz, RX BW 100kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26affd760557e6bc6c112a4a309297fb4fa" name="ac208a5ea5ced06bafa203e4a57e0ec26affd760557e6bc6c112a4a309297fb4fa"></a>GFSK_Rb10Fd19&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 10kBaud, Dev: 19kHz, RX BW 100kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26aa78bd11a651953b6ad2d6599b006ad5c" name="ac208a5ea5ced06bafa203e4a57e0ec26aa78bd11a651953b6ad2d6599b006ad5c"></a>GFSK_Rb38_4Fd20&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 38.4kBaud, Dev: 20kHz, RX BW 100kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26a4fd932d6cbdec4a2c408251a1b68e962" name="ac208a5ea5ced06bafa203e4a57e0ec26a4fd932d6cbdec4a2c408251a1b68e962"></a>GFSK_Rb76_8Fd32&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 76.8kBaud, Dev: 32kHz, RX BW 232kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26ad4d226c9c8735ae34c09c93243ec94e2" name="ac208a5ea5ced06bafa203e4a57e0ec26ad4d226c9c8735ae34c09c93243ec94e2"></a>GFSK_Rb100Fd47&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 100kBaud, Dev: 47kHz, RX BW 325kHz, optimised for sensitivity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac208a5ea5ced06bafa203e4a57e0ec26a327e9bf823c6e30c76dd5f63c377c928" name="ac208a5ea5ced06bafa203e4a57e0ec26a327e9bf823c6e30c76dd5f63c377c928"></a>GFSK_Rb250Fd127&#160;</td><td class="fielddoc"><p>GFSK, Data Rate: 250kBaud, Dev: 127kHz, RX BW 540kHz, optimised for sensitivity. </p>
</td></tr>
</table>

</div>
</div>
<a id="abac34a40d040dad3e64a2e1247e9e1b9" name="abac34a40d040dad3e64a2e1247e9e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac34a40d040dad3e64a2e1247e9e1b9">&#9670;&#160;</a></span>TransmitPower</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9">RH_CC110::TransmitPower</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These power outputs are based on the suggested optimum values for multilayer inductors in the 915MHz frequency band. Per table 5-15. Caution: these enum values are indexes into PaPowerValues. Do not change one without changing the other. Use the symbolic names, not the integer values </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a49181777000e838d49cbaea98777e1d3" name="abac34a40d040dad3e64a2e1247e9e1b9a49181777000e838d49cbaea98777e1d3"></a>TransmitPowerM30dBm&#160;</td><td class="fielddoc"><p>-30dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9ade2590f76d84bf984b46b21cfe0acf2d" name="abac34a40d040dad3e64a2e1247e9e1b9ade2590f76d84bf984b46b21cfe0acf2d"></a>TransmitPowerM20dBm&#160;</td><td class="fielddoc"><p>-20dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a5b0a18513bed5cfb24916492592246c1" name="abac34a40d040dad3e64a2e1247e9e1b9a5b0a18513bed5cfb24916492592246c1"></a>TransmitPowerM15dBm&#160;</td><td class="fielddoc"><p>-15dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a2901fc17652a7cc1d42e0fb7e472d2eb" name="abac34a40d040dad3e64a2e1247e9e1b9a2901fc17652a7cc1d42e0fb7e472d2eb"></a>TransmitPowerM10dBm&#160;</td><td class="fielddoc"><p>-10dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a292de01e04abfbcb9dab83c64e7183b1" name="abac34a40d040dad3e64a2e1247e9e1b9a292de01e04abfbcb9dab83c64e7183b1"></a>TransmitPower0dBm&#160;</td><td class="fielddoc"><p>0dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a1469abcfb3929abdb7215c2a8a415a17" name="abac34a40d040dad3e64a2e1247e9e1b9a1469abcfb3929abdb7215c2a8a415a17"></a>TransmitPower5dBm&#160;</td><td class="fielddoc"><p>5dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9aa742fb6879652ea2c684ffc6cff756f8" name="abac34a40d040dad3e64a2e1247e9e1b9aa742fb6879652ea2c684ffc6cff756f8"></a>TransmitPower7dBm&#160;</td><td class="fielddoc"><p>7dBm </p>
</td></tr>
<tr><td class="fieldname"><a id="abac34a40d040dad3e64a2e1247e9e1b9a35452211ca84528513441b67efd80bbb" name="abac34a40d040dad3e64a2e1247e9e1b9a35452211ca84528513441b67efd80bbb"></a>TransmitPower10dBm&#160;</td><td class="fielddoc"><p>10dBm </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af3af317709d0c1298c5266c00f3d8281" name="af3af317709d0c1298c5266c00f3d8281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3af317709d0c1298c5266c00f3d8281">&#9670;&#160;</a></span>RH_CC110()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RH_CC110::RH_CC110 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em> = <code>SS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptPin</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is27MHz</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_h_generic_s_p_i.html">RHGenericSPI</a> &amp;&#160;</td>
          <td class="paramname"><em>spi</em> = <code><a class="el" href="_r_h_hardware_s_p_i_8cpp.html#a9d4ea215edc388eaacbc289938bb658c">hardware_spi</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. You can have multiple instances, but each instance must have its own interrupt and slave select pin. After constructing, you must call <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a> to initialise the interface and the radio module. A maximum of 3 instances can co-exist on one processor, provided there are sufficient distinct interrupt lines, one for each instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveSelectPin</td><td>the Arduino pin number of the output to use to select the CC110L before accessing it. Defaults to the normal SS pin for your Arduino (D10 for Diecimila, Uno etc, D53 for Mega, D10 for Maple) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptPin</td><td>The interrupt Pin number that is connected to the CC110L GDO0 interrupt line. Defaults to pin 2. Caution: You must specify an interrupt capable pin. On many Arduino boards, there are limitations as to which pins may be used as interrupts. On Leonardo pins 0, 1, 2 or 3. On Mega2560 pins 2, 3, 18, 19, 20, 21. On Due and Teensy, any digital pin. On other Arduinos pins 2 or 3. See <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for more details. On Chipkit Uno32, pins 38, 2, 7, 8, 35. On other boards, any digital pin may be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is27MHz</td><td>Set to true if your CC110 is equipped with a 27MHz crystal oscillator. Defaults to false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the SPI interface object to use. Defaults to the standard Arduino hardware SPI interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af097fa9c1e8136c8dceec3400a016cbe" name="af097fa9c1e8136c8dceec3400a016cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af097fa9c1e8136c8dceec3400a016cbe">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests whether a new message is available from the Driver. On most drivers, this will also put the Driver into RHModeRx mode until a message is actually received by the transport, when it will be returned to RHModeIdle and <a class="el" href="class_r_h___c_c110.html#af097fa9c1e8136c8dceec3400a016cbe">available()</a> will return true. This can be called multiple times in a timeout loop </p><dl class="section return"><dt>Returns</dt><dd>true if a new, complete, error-free uncollected message is available to be retreived by <a class="el" href="class_r_h___c_c110.html#af0d6222531343bc248b761a033f14fd1">recv()</a> </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a2dd522b8eb16c51dc948b4ca4d623888">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a22fb6c2ccb795f6132073a4cdd0350d2" name="a22fb6c2ccb795f6132073a4cdd0350d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb6c2ccb795f6132073a4cdd0350d2">&#9670;&#160;</a></span>clearRxBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::clearRxBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear our local receive buffer. </p>

</div>
</div>
<a id="a598c51161ec8c0ace7db2a5e93b33c85" name="a598c51161ec8c0ace7db2a5e93b33c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598c51161ec8c0ace7db2a5e93b33c85">&#9670;&#160;</a></span>handleInterrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::handleInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a low level function to handle the interrupts for one instance of <a class="el" href="class_r_h___r_f95.html" title="Driver to send and receive unaddressed, unreliable datagrams via a LoRa capable radio transceiver.">RH_RF95</a>. Called automatically by isr*() Should not need to be called by user code. </p>

</div>
</div>
<a id="a8d06c990d7c776dcac9e6ba1dc7a1ff2" name="a8d06c990d7c776dcac9e6ba1dc7a1ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d06c990d7c776dcac9e6ba1dc7a1ff2">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialise the Driver transport hardware and software. Make sure the Driver is properly configured before calling <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a>. In particular, ensure you have called setIs27MHz(true) if your module has a 27MHz crystal oscillator. After <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a>, the following default characteristics are set: TxPower: TransmitPower5dBm Frequency: 915.0 Modulation: GFSK_Rb1_2Fd5_2 (GFSK, Data Rate: 1.2kBaud, Dev: 5.2kHz, RX BW 58kHz, optimised for sensitivity) Sync Words: 0xd3, 0x91 </p><dl class="section return"><dt>Returns</dt><dd>true if initialisation succeeded. </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#a3e1cfcd4d6187702c364cf4c81e76365">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a2a825fd587ed025d710ce31d7ba4c10c" name="a2a825fd587ed025d710ce31d7ba4c10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a825fd587ed025d710ce31d7ba4c10c">&#9670;&#160;</a></span>isr0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::isr0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 0. </p>

</div>
</div>
<a id="af5a72de8a53a3d524ddf76e02d900f32" name="af5a72de8a53a3d524ddf76e02d900f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a72de8a53a3d524ddf76e02d900f32">&#9670;&#160;</a></span>isr1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::isr1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 1. </p>

</div>
</div>
<a id="a3058990fcd92a8a770b05c5970ad3a20" name="a3058990fcd92a8a770b05c5970ad3a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3058990fcd92a8a770b05c5970ad3a20">&#9670;&#160;</a></span>isr2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::isr2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low level interrupt service routine for device connected to interrupt 1. </p>

</div>
</div>
<a id="a16b9f621286a3da2110fd88f75ba996d" name="a16b9f621286a3da2110fd88f75ba996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f621286a3da2110fd88f75ba996d">&#9670;&#160;</a></span>maxMessageLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::maxMessageLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum message length available in this Driver. </p><dl class="section return"><dt>Returns</dt><dd>The maximum legal message length </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a267459de4eb3032c5efb8b220af7d164">RHGenericDriver</a>.</p>

</div>
</div>
<a id="ae68f6f40ea8f4583126423b59bc2d72a" name="ae68f6f40ea8f4583126423b59bc2d72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68f6f40ea8f4583126423b59bc2d72a">&#9670;&#160;</a></span>printRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::printRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the value of all chip registers to the Serial device if RH_HAVE_SERIAL is defined for the current platform For debugging purposes only. </p><dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="af0d6222531343bc248b761a033f14fd1" name="af0d6222531343bc248b761a033f14fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d6222531343bc248b761a033f14fd1">&#9670;&#160;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::recv </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the receiver on if it not already on (after wiaint gor any currenly transmitting message to complete). If there is a valid message available, copy it to buf and return true else return false. If a message is copied, *len is set to the length (Caution, 0 length messages are permitted). You should be sure to call this function frequently enough to not miss any messages It is recommended that you call it in your main loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy the received message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pointer to available space in buf. Set to the actual number of octets copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid message was copied to buf. The message cannot be retreived again. </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a58f0f64dff770bbeb1b197a5fca0579a">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a322bcc9f798ccdbce077dadee203140e" name="a322bcc9f798ccdbce077dadee203140e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322bcc9f798ccdbce077dadee203140e">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits until any previous transmit packet is finished being transmitted with <a class="el" href="class_r_h___c_c110.html#afef87c720bf127b473e08d2cb540c32b">waitPacketSent()</a>. Then loads a message into the transmitter and starts the transmitter. Note that a message length of 0 is permitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes of data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message length was valid and it was correctly queued for transmit </dd></dl>

<p>Implements <a class="el" href="class_r_h_generic_driver.html#a5716069edea652af8019daaeb64357ee">RHGenericDriver</a>.</p>

</div>
</div>
<a id="af5bdb511a4491a4010145518782a346d" name="af5bdb511a4491a4010145518782a346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bdb511a4491a4010145518782a346d">&#9670;&#160;</a></span>setFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter and receiver centre frequency. Caution: permissable frequency bands will depend on you country and area: consult local authorities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">centre</td><td>Frequency in MHz. 300.0 to 928.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the selected frquency centre is within range </dd></dl>

</div>
</div>
<a id="ae98881aa331c7ba645464b97aaf42905" name="ae98881aa331c7ba645464b97aaf42905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98881aa331c7ba645464b97aaf42905">&#9670;&#160;</a></span>setIs27MHz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setIs27MHz </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is27MHz</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the presence of 27MHz crystal oscillator. You must indicate to the driver if your CC110L is equipped with a 27MHz crystal oscillator (26MHz is the default in the constructor). This should be called before calling <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a> if you have a 27MHz crystal. It can be called after calling <a class="el" href="class_r_h___c_c110.html#a8d06c990d7c776dcac9e6ba1dc7a1ff2">init()</a> but you must reset the frequency (with <a class="el" href="class_r_h___c_c110.html#af5bdb511a4491a4010145518782a346d">setFrequency()</a>) and modulation (with <a class="el" href="class_r_h___c_c110.html#a79e4e4637247be0e3d2e9ada303ea15f">setModemConfig()</a>) afterwards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is27MHz</td><td>Pass true if the CC110L has a 27MHz crystal (default is true). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6682a3683087941a6fbb449500e15070" name="a6682a3683087941a6fbb449500e15070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6682a3683087941a6fbb449500e15070">&#9670;&#160;</a></span>setModeIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setModeIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Sleep, Rx or Tx changes it to Idle. If the transmitter or receiver is running, disables them. </p>

</div>
</div>
<a id="a79e4e4637247be0e3d2e9ada303ea15f" name="a79e4e4637247be0e3d2e9ada303ea15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e4e4637247be0e3d2e9ada303ea15f">&#9670;&#160;</a></span>setModemConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::setModemConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_h___c_c110.html#ac208a5ea5ced06bafa203e4a57e0ec26">ModemConfigChoice</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select one of the predefined modem configurations. If you need a modem configuration not provided here, use <a class="el" href="class_r_h___c_c110.html#a5f0ea46f235abc91130511fc461f8907">setModemRegisters()</a> with your own <a class="el" href="struct_r_h___c_c110_1_1_modem_config.html" title="Defines register configuration values for a desired modulation.">ModemConfig</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The configuration choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is a valid choice. </dd></dl>

</div>
</div>
<a id="a5f0ea46f235abc91130511fc461f8907" name="a5f0ea46f235abc91130511fc461f8907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0ea46f235abc91130511fc461f8907">&#9670;&#160;</a></span>setModemRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setModemRegisters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_h___c_c110_1_1_modem_config.html">ModemConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all the registers required to configure the data modem in the CC110, including the data rate, bandwidths etc. You cas use this to configure the modem with custom configuraitons if none of the canned configurations in ModemConfigChoice suit you. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="struct_r_h___c_c110_1_1_modem_config.html" title="Defines register configuration values for a desired modulation.">ModemConfig</a> structure containing values for the modem configuration registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab88e69f00f69c414b08870a9c077a9d" name="aab88e69f00f69c414b08870a9c077a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88e69f00f69c414b08870a9c077a9d">&#9670;&#160;</a></span>setModeRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setModeRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Tx or Idle, changes it to Rx. Starts the receiver. The radio will stay in Rx mode until a CRC correct message addressed to this node is received, or the ode is changed to Tx, Idle or Sleep. </p>

</div>
</div>
<a id="af12356a202823b54f7bc5b3567738a48" name="af12356a202823b54f7bc5b3567738a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12356a202823b54f7bc5b3567738a48">&#9670;&#160;</a></span>setModeTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setModeTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Idle, changes it to Tx. Starts the transmitter sending the current message. </p>

</div>
</div>
<a id="aae97a2582b984fe078a5c85cb03fd2bc" name="aae97a2582b984fe078a5c85cb03fd2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae97a2582b984fe078a5c85cb03fd2bc">&#9670;&#160;</a></span>setPaTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setPaTable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>patable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>patablesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PaTable registers directly. Ensure you use suitable PATABLE values per Tbale 5-15 or 5-16 You may need to do this to implement an OOK modulation scheme. </p>

</div>
</div>
<a id="aba36c862098176950fc152e41eda374c" name="aba36c862098176950fc152e41eda374c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba36c862098176950fc152e41eda374c">&#9670;&#160;</a></span>setSyncWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::setSyncWords </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>syncWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sync words for transmit and receive in registers RH_CC110_REG_04_SYNC1 and RH_CC110_REG_05_SYNC0. Caution: SyncWords should be set to the same value on all nodes in your network. Nodes with different SyncWords set will never receive each others messages, so different SyncWords can be used to isolate different networks from each other. Default is { 0xd3, 0x91 }. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">syncWords</td><td>Array of sync words, 2 octets long </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of sync words to set. MUST be 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab95e2ccd99a4fc47d3ec273ba7927e62" name="ab95e2ccd99a4fc47d3ec273ba7927e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95e2ccd99a4fc47d3ec273ba7927e62">&#9670;&#160;</a></span>setTxPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::setTxPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_h___c_c110.html#abac34a40d040dad3e64a2e1247e9e1b9">TransmitPower</a>&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the Power Amplifier power setting. The PaTable settings are based on are based on the suggested optimum values for multilayer inductors in the 915MHz frequency band. Per table 5-15. If these values are not suitable, use <a class="el" href="class_r_h___c_c110.html#aae97a2582b984fe078a5c85cb03fd2bc">setPaTable()</a> directly. Caution: be a good neighbour and use the lowest power setting compatible with your application. Caution: Permissable power settings for your area may depend on frequency and modulation characteristics: consult local authorities. param[in] power One of TransmitPower enum values <br  />
 </p>

</div>
</div>
<a id="aab9e12b3206e733d8e200547211781ea" name="aab9e12b3206e733d8e200547211781ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9e12b3206e733d8e200547211781ea">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the radio into low-power sleep mode. If successful, the transport will stay in sleep mode until woken by changing mode to idle, transmit or receive (eg by calling <a class="el" href="class_r_h___c_c110.html#a322bcc9f798ccdbce077dadee203140e">send()</a>, <a class="el" href="class_r_h___c_c110.html#af0d6222531343bc248b761a033f14fd1">recv()</a>, <a class="el" href="class_r_h___c_c110.html#af097fa9c1e8136c8dceec3400a016cbe">available()</a> etc) Caution: there is a time penalty as the radio takes a finite time to wake from sleep mode. Caution: waking up from sleep loses values from registers 0x29 through 0x2e </p><dl class="section return"><dt>Returns</dt><dd>true if sleep mode was successfully entered. </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#a97050555cbf46ad723ad9c45d7f76a55">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a2b7ff7cb91bf6f2f210049629640d840" name="a2b7ff7cb91bf6f2f210049629640d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7ff7cb91bf6f2f210049629640d840">&#9670;&#160;</a></span>spiBurstReadRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::spiBurstReadRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a single register in burst mode. On the CC110L, some registers yield different data when read in burst mode as opposed to single byte mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number, one of RH_CC110_REG (burst mode readable) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the register after a burst read </dd></dl>

</div>
</div>
<a id="abbe64dd011a064b6d2253170fcd40b4f" name="abbe64dd011a064b6d2253170fcd40b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe64dd011a064b6d2253170fcd40b4f">&#9670;&#160;</a></span>spiBurstWriteRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::spiBurstWriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a number of bytes to a burst capable register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number of the first register, one of RH_CC110L_REG_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array of new register values to write. Must be at least len bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chip status byte per table 5.2 </dd></dl>

</div>
</div>
<a id="ade4cc83f2a3df61dc6c82c96ee3e0c89" name="ade4cc83f2a3df61dc6c82c96ee3e0c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4cc83f2a3df61dc6c82c96ee3e0c89">&#9670;&#160;</a></span>spiReadRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::spiReadRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a single register from the CC110L </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number, one of RH_CC110_REG </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the register </dd></dl>

</div>
</div>
<a id="a2366878f8093ac2adb5c3c951ad79001" name="a2366878f8093ac2adb5c3c951ad79001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2366878f8093ac2adb5c3c951ad79001">&#9670;&#160;</a></span>spiWriteRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::spiWriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes to a single single register on the CC110L </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number, one of RH_CC110L_REG_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the chip status byte per table 5.2 </dd></dl>

</div>
</div>
<a id="a9e4a41f2217a70082084b21110442336" name="a9e4a41f2217a70082084b21110442336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4a41f2217a70082084b21110442336">&#9670;&#160;</a></span>statusRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::statusRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads and returns the status byte by issuing the SNOP strobe </p><dl class="section return"><dt>Returns</dt><dd>The value of the status byte per Table 5-2 </dd></dl>

</div>
</div>
<a id="a80c85807541d9e78a01a33992e8799bb" name="a80c85807541d9e78a01a33992e8799bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c85807541d9e78a01a33992e8799bb">&#9670;&#160;</a></span>validateRxBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_CC110::validateRxBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Examine the receive buffer to determine whether the message is for this node Sets _rxBufValid. </p>

</div>
</div>
<a id="afef87c720bf127b473e08d2cb540c32b" name="afef87c720bf127b473e08d2cb540c32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef87c720bf127b473e08d2cb540c32b">&#9670;&#160;</a></span>waitPacketSent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::waitPacketSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until the current message (if any) has been transmitted </p><dl class="section return"><dt>Returns</dt><dd>true on success, false if the chip is not in transmit mode or other transmit failure </dd></dl>

<p>Reimplemented from <a class="el" href="class_r_h_generic_driver.html#a7506f47e9a391ffa05f7271950c26ffe">RHGenericDriver</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a83b87dbcff0d87475b81924311992504" name="a83b87dbcff0d87475b81924311992504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b87dbcff0d87475b81924311992504">&#9670;&#160;</a></span>_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::_buf[RH_CC110_MAX_PAYLOAD_LEN]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The receiver/transmitter buffer. </p>

</div>
</div>
<a id="a030a786595bb5a4116fa4ad8fd284d3c" name="a030a786595bb5a4116fa4ad8fd284d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030a786595bb5a4116fa4ad8fd284d3c">&#9670;&#160;</a></span>_bufLen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t RH_CC110::_bufLen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of octets in the buffer. </p>

</div>
</div>
<a id="a53e2a54933fc10a505bb4a5f6f4aabd2" name="a53e2a54933fc10a505bb4a5f6f4aabd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e2a54933fc10a505bb4a5f6f4aabd2">&#9670;&#160;</a></span>_deviceForInterrupt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_h___c_c110.html">RH_CC110</a> * RH_CC110::_deviceForInterrupt = {0, 0, 0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of instances connected to interrupts 0 and 1. </p>

</div>
</div>
<a id="a7bbe0a46650a2e12a94bd9b0e6c76dba" name="a7bbe0a46650a2e12a94bd9b0e6c76dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbe0a46650a2e12a94bd9b0e6c76dba">&#9670;&#160;</a></span>_interruptCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::_interruptCount = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of next interrupt number to use in _deviceForInterrupt. </p>

</div>
</div>
<a id="a38710fe45f29692c3a3b1f660662b243" name="a38710fe45f29692c3a3b1f660662b243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38710fe45f29692c3a3b1f660662b243">&#9670;&#160;</a></span>_interruptPin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::_interruptPin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The configured interrupt pin connected to this instance. </p>

</div>
</div>
<a id="a98c2d5f5ee84926f5f675b8425137757" name="a98c2d5f5ee84926f5f675b8425137757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c2d5f5ee84926f5f675b8425137757">&#9670;&#160;</a></span>_is27MHz</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_CC110::_is27MHz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if crystal oscillator is 26 MHz, not 26MHz. </p>

</div>
</div>
<a id="a344cf5fa5a1cc3691a824d011c9545b5" name="a344cf5fa5a1cc3691a824d011c9545b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344cf5fa5a1cc3691a824d011c9545b5">&#9670;&#160;</a></span>_myInterruptIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_CC110::_myInterruptIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The index into _deviceForInterrupt[] for this device (if an interrupt is already allocated) else 0xff </p>

</div>
</div>
<a id="a253759c4ae98449b11555206bfb9e30d" name="a253759c4ae98449b11555206bfb9e30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253759c4ae98449b11555206bfb9e30d">&#9670;&#160;</a></span>_rxBufValid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool RH_CC110::_rxBufValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True when there is a valid message in the buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_r_h___c_c110_8h_source.html">RH_CC110.h</a></li>
<li><a class="el" href="_r_h___c_c110_8cpp.html">RH_CC110.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath">
    <!-- id is needed for treeview function! -->
    <ul>
        <li class="navelem"><a class="el" href="class_r_h___c_c110.html">RH_CC110</a></li>
        <li class="footer">
            Generated on Tue Feb 14 2023 15:58:23 for Soldered RF433 Arduino Library by <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"
                    onerror="this.onerror=null;this.src='doxygen.svg';" /></a> 1.9.6.
            Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
            Copyright: <a href="https://www.soldered.com">Soldered</a>
        </li>
    </ul>
</div>
<script src="custom.js"></script>
</body>
</html>
